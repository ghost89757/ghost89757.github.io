<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>王爽《汇编语言》总结 | loudmute</title><meta name="author" content="loudmute,2779477538@qq.com"><meta name="copyright" content="loudmute"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="前言起因是因为操作系统，本来是打算跟南大JYY的操作系统课，上了两节，md听不懂，只能感到自己像个弱智。于是又去跟哈工大LZZ的课，还是听不懂，细究起来主要是他们讲汇编的时候，我没学过，一脸懵逼。网上有帖子说，学之前可以学一下王爽的《汇编语言》，于是搜刮了一些资料。一开始，我是抱着速通去的，花了三四天看完了这本书，然后接着听课，结果是囫囵吞枣、一事无成。痛定思痛，我又花了一周半的时间，好好学了这本">
<meta property="og:type" content="article">
<meta property="og:title" content="王爽《汇编语言》总结">
<meta property="og:url" content="https://ghost89757.github.io/post/1ded95c1.html">
<meta property="og:site_name" content="loudmute">
<meta property="og:description" content="前言起因是因为操作系统，本来是打算跟南大JYY的操作系统课，上了两节，md听不懂，只能感到自己像个弱智。于是又去跟哈工大LZZ的课，还是听不懂，细究起来主要是他们讲汇编的时候，我没学过，一脸懵逼。网上有帖子说，学之前可以学一下王爽的《汇编语言》，于是搜刮了一些资料。一开始，我是抱着速通去的，花了三四天看完了这本书，然后接着听课，结果是囫囵吞枣、一事无成。痛定思痛，我又花了一周半的时间，好好学了这本">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://ghost89757.github.io/img/7.jpg">
<meta property="article:published_time" content="2023-10-01T00:47:48.000Z">
<meta property="article:modified_time" content="2023-10-08T05:07:26.195Z">
<meta property="article:author" content="loudmute">
<meta property="article:tag" content="编程">
<meta property="article:tag" content="汇编">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://ghost89757.github.io/img/7.jpg"><link rel="shortcut icon" href="/img/cat-11.png"><link rel="canonical" href="https://ghost89757.github.io/post/1ded95c1"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '王爽《汇编语言》总结',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-10-08 13:07:26'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/transpancy.css"><link rel="stylesheet" href="/css/modify.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>const preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> { preloader.endLoading() })

if (false) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/head-1.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">35</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">23</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">16</div></a></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/7.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">loudmute</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">王爽《汇编语言》总结</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-10-01T00:47:48.000Z" title="发表于 2023-10-01 08:47:48">2023-10-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-10-08T05:07:26.195Z" title="更新于 2023-10-08 13:07:26">2023-10-08</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BC%96%E7%A8%8B/">编程</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BC%96%E7%A8%8B/%E6%B1%87%E7%BC%96/">汇编</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">13.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>49分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="王爽《汇编语言》总结"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><div class="top-img" style="background-image: url('/img/7.jpg');"></div><article class="post-content" id="article-container"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>起因是因为操作系统，本来是打算跟南大JYY的操作系统课，上了两节，md听不懂，只能感到自己像个弱智。于是又去跟哈工大LZZ的课，还是听不懂，细究起来主要是他们讲汇编的时候，我没学过，一脸懵逼。网上有帖子说，学之前可以学一下王爽的《汇编语言》，于是搜刮了一些资料。一开始，我是抱着速通去的，花了三四天看完了这本书，然后接着听课，结果是囫囵吞枣、一事无成。痛定思痛，我又花了一周半的时间，好好学了这本《汇编语言》。不得不说，这本书写的太好了，完全就是让你可以自己从头看到尾，当然，最重要的是书里的代码，实验的代码，都写了一遍。你可能不信，我甚至在写汇编指令的时候感到了前所未有的快感，既然好好学了，就写个笔记吧，于是就有了这篇总结。</p>
<p>这篇总结淡化了大部分的硬件知识，以及大部分的文字，重点突出指令和我认为有意思的代码，又由于懒得重新构思大纲，就按着作者的原书架构来总结，原书一共17章，由于我希望这篇总结像指令大全一样可以速查，所以我只总结了重要的指令部分以及相关代码，原书的1、16、17章并没有介绍重要的指令，所以就省略了。</p>
<h2 id="一-基础知识"><a href="#一-基础知识" class="headerlink" title="一-基础知识"></a>一-基础知识</h2><p>略…</p>
<h2 id="二-寄存器（指令访问）"><a href="#二-寄存器（指令访问）" class="headerlink" title="二-寄存器（指令访问）"></a>二-寄存器（指令访问）</h2><h3 id="1-几条汇编指令"><a href="#1-几条汇编指令" class="headerlink" title="1 几条汇编指令"></a>1 几条汇编指令</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov ax, 18 ;将18送入寄存器AX</span><br><span class="line">mov ah, 78 ;将78送入寄存器AH</span><br><span class="line">add ax, 8 ;将寄存器AX中的数值加上8</span><br><span class="line">mov ax, bx ;将寄存器BX中的数据送入寄存器AX</span><br><span class="line">add ax, bx ;将AX和BX中的数值相加，结果存在AX中</span><br></pre></td></tr></tbody></table></figure>

<h3 id="2-CS和IP"><a href="#2-CS和IP" class="headerlink" title="2 CS和IP"></a>2 CS和IP</h3><h4 id="2-1-相关概念"><a href="#2-1-相关概念" class="headerlink" title="2.1 相关概念"></a>2.1 相关概念</h4><ul>
<li><p>CS和IP指出了CPU当前要读取指令的地址</p>
</li>
<li><p>CS是代码段寄存器，假设储存内容为M；IP是指令指针寄存器，假设储存内容为N</p>
</li>
<li><p>根据CS:IP，CPU访问的内存单元的物理地址为$M * 16 + N$</p>
</li>
<li><p>在X86结构中，任意时刻，CPU将CS:IP指向的内容当作指令执行</p>
</li>
<li><p>CPU取指令执行的过程：</p>
<ul>
<li>（1） 从CS：IP指向的内存单元读取指令，放入指令缓存器</li>
<li>（2）IP = IP + 所读指令的长度，指向下一条指令</li>
<li>（3）执行指令，跳转到（1）</li>
<li>重复这3个步骤</li>
</ul>
</li>
</ul>
<h4 id="2-2-相关指令"><a href="#2-2-相关指令" class="headerlink" title="2.2 相关指令"></a>2.2 相关指令</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jmp 段地址:偏移地址 ;执行后，cs = 给定段地址，ip = 给定偏移地址</span><br><span class="line">jmp 某一合法寄存器 ;执行后，修改ip，ip = 给定寄存器中的值</span><br></pre></td></tr></tbody></table></figure>

<h2 id="三-寄存器（内存访问）"><a href="#三-寄存器（内存访问）" class="headerlink" title="三-寄存器（内存访问）"></a>三-寄存器（内存访问）</h2><h3 id="1-DS和-address"><a href="#1-DS和-address" class="headerlink" title="1 DS和[address]"></a>1 DS和[address]</h3><h4 id="1-1-相关概念"><a href="#1-1-相关概念" class="headerlink" title="1.1 相关概念"></a>1.1 相关概念</h4><ul>
<li>内存地址由段地址和偏移地址组成</li>
<li>DS是一个段寄存器，通常用来存放访问存放数据所需的段地址</li>
<li>[address]表示一个内存单元，段地址由ds提供，address为偏移地址</li>
</ul>
<h4 id="1-2-相关指令"><a href="#1-2-相关指令" class="headerlink" title="1.2 相关指令"></a>1.2 相关指令</h4><ul>
<li><p>将内存单元1000:0中的字型数据传送到AX寄存器</p>
  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov bx, 1000</span><br><span class="line">mov ds, bx</span><br><span class="line">mov ax, [0]</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>注意，X86不支持直接将数据送入段寄存器，通常需要通用寄存器做中介</p>
</li>
</ul>
<h3 id="2-mov、add、sub指令"><a href="#2-mov、add、sub指令" class="headerlink" title="2 mov、add、sub指令"></a>2 mov、add、sub指令</h3><p>mov，add，sub目前可以有的几种形式，这里用option代替mov\add\sub：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">option 寄存器, 数据</span><br><span class="line">option 寄存器,寄存器</span><br><span class="line">option 寄存器, 内存单元</span><br><span class="line">option 内存单元, 寄存器</span><br><span class="line">option 段寄存器, 寄存器</span><br><span class="line">option 寄存器, 段寄存器</span><br></pre></td></tr></tbody></table></figure>

<h3 id="3-栈"><a href="#3-栈" class="headerlink" title="3 栈"></a>3 栈</h3><h4 id="3-1-相关概念"><a href="#3-1-相关概念" class="headerlink" title="3.1 相关概念"></a>3.1 相关概念</h4><ul>
<li>栈是一种具有特殊访问方式的存储空间，特殊在数据的“先进后出”</li>
<li>X86的入栈和出栈都是以字为单位的，栈的内存单元往往是偶数个</li>
<li>SS和SP<ul>
<li>栈顶的地址有SS和SP提供</li>
<li>栈顶的段地址存放在段寄存器SS中，偏移地址存放在寄存器SP中</li>
<li>任意时刻，SS:SP指向栈顶元素</li>
</ul>
</li>
<li>栈的底部是最高地址，顶部是相对较低地址；当数据入栈时，栈顶指向的地址越来越低。</li>
<li>栈空时，SS:SP指向最高地址的下一个单元；栈满事，SS:SP指向最低地址</li>
<li>X86不会保证栈操作不会越界，一旦越界，将对栈空间以外的内存单元造成影响</li>
</ul>
<h4 id="3-2-相关指令"><a href="#3-2-相关指令" class="headerlink" title="3.2 相关指令"></a>3.2 相关指令</h4><ul>
<li><p>入栈</p>
  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">push ax ;将ax中的内容入栈</span><br></pre></td></tr></tbody></table></figure>

<p>  该指令执行两步操作：</p>
<p>  （1）SP = SP - 2，SS:SP指向新的栈顶</p>
<p>  （2）将AX寄存器中的内容送入SS:SP指向的内存单元处</p>
</li>
<li><p>出栈</p>
  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pop ax ;将栈顶指向的内存单元数据弹出，送入ax</span><br></pre></td></tr></tbody></table></figure>

<p>  该指令执行两步操作：</p>
<p>  （1）将SS:SP指向内存单元的数据送入AX寄存器</p>
<p>  （2）SP = SP + 2，SS:SP指向新栈顶</p>
</li>
<li><p>指令形式</p>
<ul>
<li><p>与寄存器</p>
  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push 寄存器 ;将一个寄存器中的数据入栈</span><br><span class="line">pop 寄存器 ;出栈，栈顶元素送入寄存器</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>与段寄存器</p>
  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push 段寄存器</span><br><span class="line">pop 段寄存器</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>与内存单元</p>
  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push 内存单元</span><br><span class="line">pop 内存单元</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
</li>
</ul>
<h2 id="四-第一个程序"><a href="#四-第一个程序" class="headerlink" title="四-第一个程序"></a>四-第一个程序</h2><h3 id="1-一个程序从写出到执行的过程"><a href="#1-一个程序从写出到执行的过程" class="headerlink" title="1 一个程序从写出到执行的过程"></a>1 一个程序从写出到执行的过程</h3><ul>
<li>（1）编写汇编程序，产生一个文本文件（.asm）</li>
<li>（2）对源程序进行编译，产生一个目标文件（.obj）</li>
<li>（3）对目标文件进行连接，产生一个可执行文件（.exe）</li>
<li>（4）借助操作系统将程序加载到内存中</li>
<li>（5）程序运行</li>
</ul>
<h3 id="2-一个简单的源程序"><a href="#2-一个简单的源程序" class="headerlink" title="2 一个简单的源程序"></a>2 一个简单的源程序</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codeseg ;将codeseg段和寄存器关联起来</span><br><span class="line"></span><br><span class="line">codeseg segment ;定义了一个段，段名为“codeseg”，段由此开始</span><br><span class="line"></span><br><span class="line">    mov ax, 0123H </span><br><span class="line">    mov bx, 4567H</span><br><span class="line">    add ax, ax</span><br><span class="line">    add bx, bx</span><br><span class="line"></span><br><span class="line">    ;实现程序返回</span><br><span class="line">    mov ax, 4c00H</span><br><span class="line">    int 21H</span><br><span class="line"></span><br><span class="line">codeseg ends ;名为“codeseg”的段结束</span><br><span class="line"></span><br><span class="line">end ;整个汇编程序结束</span><br></pre></td></tr></tbody></table></figure>

<h2 id="五-BX-和loop指令"><a href="#五-BX-和loop指令" class="headerlink" title="五-[BX]和loop指令"></a>五-[BX]和loop指令</h2><p>我们首先约定，符号”(…)”表示…中的内容，比如(ax)表示寄存器AX中的内容；idata表示一个立即数。</p>
<h3 id="1-BX"><a href="#1-BX" class="headerlink" title="1 [BX]"></a>1 [BX]</h3><ul>
<li>[bx]表示一个内存单元</li>
<li>段地址默认为(ds)，偏移地址为(bx)</li>
<li>[idata]的虽然也表示一个内存单元，但是idata是一个立即数，不能修改；[bx]中的bx是一个寄存器，其内容是可以修改的，这样访问内存更加灵活</li>
</ul>
<h3 id="2-Loop指令"><a href="#2-Loop指令" class="headerlink" title="2 Loop指令"></a>2 Loop指令</h3><ul>
<li><p>指令格式：</p>
  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loop 标号</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>指令执行时的两步操作：</p>
<ul>
<li>（1）(cx) = (cx) - 1</li>
<li>（2）判断cx中的值，不为0则跳转至标号处执行程序，为0向下执行</li>
</ul>
</li>
<li><p>CX寄存器默认存放着loop的循环次数</p>
</li>
<li><p>loop和cx指令配合实现循环的程序框架：</p>
  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">	mov cx, 循环次数</span><br><span class="line">s:	循环执行的程序段</span><br><span class="line">	loop s</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h3 id="3-段前缀"><a href="#3-段前缀" class="headerlink" title="3 段前缀"></a>3 段前缀</h3><h4 id="3-1-相关概念-1"><a href="#3-1-相关概念-1" class="headerlink" title="3.1 相关概念"></a>3.1 相关概念</h4><p>在访问一个内存单元[address]时，我们默认段地址由DS寄存器给出，我们可以显示的给出内存单元所在的段寄存器：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov ax, ds:[bx]</span><br></pre></td></tr></tbody></table></figure>

<p>在这条指令中，”ds:”就是段前缀。</p>
<h4 id="3-2-段前缀的使用"><a href="#3-2-段前缀的使用" class="headerlink" title="3.2 段前缀的使用"></a>3.2 段前缀的使用</h4><p>我们写一个程序来解决这个问题：将内存ffff:0-ffff:b单元中的数据复制到0:200-0:20b单元中。</p>
<p>不使用段前缀，应该这么写：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">    mov bx, 0</span><br><span class="line"></span><br><span class="line">    mov cx, 12</span><br><span class="line">s:  mov ax, 0ffffh</span><br><span class="line">    mov ds, ax</span><br><span class="line">    mov dl, [bx]</span><br><span class="line"></span><br><span class="line">    mov ax, 0020h</span><br><span class="line">    mov ds, ax</span><br><span class="line">    mov [bx], dl</span><br><span class="line"></span><br><span class="line">    inc bx</span><br><span class="line">    loop s</span><br><span class="line"></span><br><span class="line">    mov ax, 4c00h</span><br><span class="line">    int 21h</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></tbody></table></figure>

<p>可以看到，在每一次循环中，我们都先让(ds) = 0ffffh，把内存读入dl中，又让(ds) = 0020h，把dl中的数据再送入对应内存单元中，这样也就要进行两次段地址的复制操作。</p>
<p>现在我们使用段前缀，增加一个目的段地址，用es来存储，代码如下：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">    mov bx, 0</span><br><span class="line">    mov ax, 0ffffh</span><br><span class="line">    mov ds, ax</span><br><span class="line">    mov ax, 0020h</span><br><span class="line">    mov es, ax</span><br><span class="line"></span><br><span class="line">    mov cx, 12</span><br><span class="line">s:  mov bl, ds:[bx]</span><br><span class="line">    mov es:[bx], bl</span><br><span class="line">    inc bx</span><br><span class="line">    loop s</span><br><span class="line"></span><br><span class="line">    mov ax, 4c00h</span><br><span class="line">    int 21h</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></tbody></table></figure>

<p>这样，我们只需要在循环前定义好源段地址和目的段地址，在循环中直接进行数据传送就行了，不仅可读性强，循环中的操作也简练了许多。</p>
<h2 id="六-包含多个段的程序"><a href="#六-包含多个段的程序" class="headerlink" title="六-包含多个段的程序"></a>六-包含多个段的程序</h2><h3 id="1-在代码段中使用数据"><a href="#1-在代码段中使用数据" class="headerlink" title="1 在代码段中使用数据"></a>1 在代码段中使用数据</h3><h4 id="1-1-定义数据"><a href="#1-1-定义数据" class="headerlink" title="1.1 定义数据"></a>1.1 定义数据</h4><ul>
<li><p>指令格式</p>
  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dw 数据1, 数据2, ..., 数据n ;定义了n个字型数据，共占 n * 2个内存单元</span><br><span class="line">db 数据1, 数据2, ..., 数据n ;定义了n个字节型数据，共占 n 个内存单元</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>数据空间的地址</p>
<p>  我们在代码段的开始定义了数据，程序刚运行时，CS:IP指向其实代码段，所以下面代码中的数据空间的段地址就是CS，根据每个数据所占内存大小，偏移地址从0开始递增2。</p>
  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">assume cs : code</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">    dw 0123h, 0456h, 0789h, 0abch</span><br><span class="line">    ;空间地址:</span><br><span class="line">    ;   CS:0,  CS:2,  CS:4,  CS:6</span><br><span class="line"></span><br><span class="line">    mov bx, 0</span><br><span class="line">    mov ax, 0</span><br><span class="line"></span><br><span class="line">    mov ax, 4</span><br><span class="line">s:  add ax, cs:[bx]</span><br><span class="line">    add bx, 2</span><br><span class="line">    loop s</span><br><span class="line"></span><br><span class="line">    mov ax, 4c00h</span><br><span class="line">    int 21h</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line"></span><br><span class="line">end</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h4 id="1-2-指明程序入口"><a href="#1-2-指明程序入口" class="headerlink" title="1.2 指明程序入口"></a>1.2 指明程序入口</h4><p>我们在上面中的代码有个问题：直接运行该程序，由于CS:IP开始是指向了一段空间，而不是一条指令，这样后续的指令无法得到执行。这时候就需要指明程序的入口。</p>
<p>我们对上面的程序进行改进：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">assume cs : code</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">    dw 0123h, 0456h, 0789h, 0abch</span><br><span class="line">    ;空间地址:</span><br><span class="line">    ;   CS:0,  CS:2,  CS:4,  CS:6</span><br><span class="line"></span><br><span class="line">start:  mov bx, 0</span><br><span class="line">        mov ax, 0</span><br><span class="line"></span><br><span class="line">        mov cx, 4</span><br><span class="line">    s:  add ax, cs:[bx]</span><br><span class="line">        add bx, 2</span><br><span class="line">        loop s</span><br><span class="line"></span><br><span class="line">        mov ax, 4c00h</span><br><span class="line">        int 21h</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>end的作用：指明程序入口，表示程序的结束</li>
<li>start：程序段的标号</li>
<li>程序执行时，CS:IP指向”mov bx, 0”</li>
</ul>
<h3 id="2-在代码段中使用栈"><a href="#2-在代码段中使用栈" class="headerlink" title="2 在代码段中使用栈"></a>2 在代码段中使用栈</h3><p>定义一段数据空间，将其作为栈使用：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">assume cs : code</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">    dw 0, 0, 0, 0</span><br><span class="line">    </span><br><span class="line">    start:  mov ax, cs</span><br><span class="line">            mov ss, ax</span><br><span class="line">            mov sp, 08h ;栈顶指向CS:8</span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">            mov ax, 4c00h</span><br><span class="line">            int 21h</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></tbody></table></figure>

<p>使用栈解决问题：将数据0123h, 2345h, 3456h, 5678h在原有空间中逆序存放。</p>
<p>代码如下：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">assume cs : code</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">    dw 0123h, 2345h, 3456h, 5678h</span><br><span class="line">    dw 0, 0, 0, 0</span><br><span class="line">    start:  mov ax, cs</span><br><span class="line">            mov ss, ax</span><br><span class="line">            mov sp, 10h</span><br><span class="line"></span><br><span class="line">            mov bx, 0</span><br><span class="line">            mov cx, 4</span><br><span class="line">        s1: push cs:[bx]</span><br><span class="line">            add bx, 2</span><br><span class="line">            loop s1</span><br><span class="line"></span><br><span class="line">            mov bx, 0</span><br><span class="line">            mov cx, 4</span><br><span class="line">        s2: pop cs:[bx]</span><br><span class="line">            add bx, 2</span><br><span class="line">            loop s2</span><br><span class="line"></span><br><span class="line">            mov ax, 4c00h</span><br><span class="line">            int 21h </span><br><span class="line">code ends</span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></tbody></table></figure>

<h3 id="3-将数据、代码、栈放入不同的段"><a href="#3-将数据、代码、栈放入不同的段" class="headerlink" title="3 将数据、代码、栈放入不同的段"></a>3 将数据、代码、栈放入不同的段</h3><p>程序中使用多个段必要性：</p>
<ul>
<li>内存角度：我们通过在源程序中定义段来进行内存空间的获取，使用不同段可以时不同用途的数据分配到相应的空间，避免内存冲突，并且一个段的空间有限，在X86结构中最大空间为64KB</li>
<li>程序设计角度：大多数有用的程序，都要处理数据、栈空间，为了代码的可读性，我们定义不同的段来时程序更加清晰明了</li>
</ul>
<p>现在我们使用多个段，对上面逆序存放数据的代码进行改写：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">assume cs : code, ds : data, ss : stack</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">    dw 0123h, 2345h, 3456h, 5678h</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">stack segment</span><br><span class="line">    dw 0, 0, 0, 0</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:  mov ax, stack</span><br><span class="line">        mov ss, ax</span><br><span class="line">        mov sp, 08h</span><br><span class="line"></span><br><span class="line">        mov ax, data</span><br><span class="line">        mov ds, ax</span><br><span class="line"></span><br><span class="line">        mov bx, 0</span><br><span class="line">        mov cx, 4</span><br><span class="line">    s1: push [bx]</span><br><span class="line">        add bx, 2</span><br><span class="line">        loop s1</span><br><span class="line"></span><br><span class="line">        mov bx, 0</span><br><span class="line">        mov cx, 4</span><br><span class="line">    s2: pop [bx]</span><br><span class="line">        add bx, 2</span><br><span class="line">        loop s2</span><br><span class="line"></span><br><span class="line">        mov ax, 4c00h</span><br><span class="line">        int 21h </span><br><span class="line">code ends</span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>定义每一段的方式与定义代码段的方式相同</li>
<li>每一段的标号代表了该段的段地址</li>
<li>段的安排只是逻辑上的，物理上并无变化</li>
</ul>
<h2 id="七-更灵活的定义内存地址的方法"><a href="#七-更灵活的定义内存地址的方法" class="headerlink" title="七-更灵活的定义内存地址的方法"></a>七-更灵活的定义内存地址的方法</h2><h3 id="1-and-和-or-指令"><a href="#1-and-和-or-指令" class="headerlink" title="1 and 和 or 指令"></a>1 and 和 or 指令</h3><ul>
<li><p>and指令</p>
<ul>
<li>逻辑与指令，按位进行与运算</li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov al, 01100011B</span><br><span class="line">and al, 00111011B</span><br></pre></td></tr></tbody></table></figure>

<p>执行后，al = 00100011B</p>
</li>
<li><p>or指令</p>
<ul>
<li>逻辑或指令，按位进行或运算</li>
</ul>
  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov al, 01100011B</span><br><span class="line">or al, 00111011B</span><br></pre></td></tr></tbody></table></figure>

<p>  执行后，al = 01111011B</p>
</li>
</ul>
<h3 id="2-以字符形式给出的数据"><a href="#2-以字符形式给出的数据" class="headerlink" title="2 以字符形式给出的数据"></a>2 以字符形式给出的数据</h3><ul>
<li><p>指令格式：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db '字符串'</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db 'unIX' ;相当于 db 75h, 6Eh, 49h, 58h</span><br></pre></td></tr></tbody></table></figure>

<p>定义字符型数据相当于定义每个字符对应的ACSII码值对应的二进制码</p>
</li>
</ul>
<h3 id="3-大小写转换的问题"><a href="#3-大小写转换的问题" class="headerlink" title="3 大小写转换的问题"></a>3 大小写转换的问题</h3><ul>
<li><p>问题：</p>
<p>  定义一个数据段，数据段中有两个字符串，分别为’BaSiC’和’iNfOrMaTiOn’，将第一个字符串中的小写字母改成大写，第二个字符串中的大写字母改成小写</p>
</li>
<li><p>核心思想：</p>
<p>  已知，’A’的二进制码为：01000001，’a’的二进制码为：01100001，二者只有第六位不同，观察ASCII表可以发现其他的字母也是这样，我们可以根据第六位的值是0还是1来表示字符的大小写。</p>
</li>
<li><p>代码：</p>
  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">assume cs : code, ds : data</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">    db 'BaSiC'</span><br><span class="line">    db 'iNfOrMaTiOn'</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:  mov ax, data</span><br><span class="line">        mov ds, ax</span><br><span class="line">        mov bx, 0</span><br><span class="line"></span><br><span class="line">        mov cx, 5</span><br><span class="line">    s1: mov al, [bx]</span><br><span class="line">        and al, 11011111B</span><br><span class="line">        mov [bx], al</span><br><span class="line">        inc bx</span><br><span class="line">        loop s1</span><br><span class="line">    </span><br><span class="line">        </span><br><span class="line">        mov cx, 11</span><br><span class="line">    s2: mov al, [bx]</span><br><span class="line">        or al, 00100000B</span><br><span class="line">        mov [bx], al</span><br><span class="line">        inc bx</span><br><span class="line">        loop s2</span><br><span class="line"></span><br><span class="line">        mov ax, 4c00h</span><br><span class="line">        int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h3 id="4-bx-idata"><a href="#4-bx-idata" class="headerlink" title="4 [bx + idata]"></a>4 [bx + idata]</h3><h4 id="4-1-相关概念"><a href="#4-1-相关概念" class="headerlink" title="4.1 相关概念"></a>4.1 相关概念</h4><ul>
<li><p>[bx + idata]，表示一个内存单元，其偏移地址为 (bx) + idata</p>
</li>
<li><p>等价形式</p>
  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[bx + idata]</span><br><span class="line">&lt;=&gt;</span><br><span class="line">idata[bx]</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>eg:</p>
  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov ax, [bx + 100]</span><br></pre></td></tr></tbody></table></figure>
<p>  该指令的意思是，将一个内存单元送入ax，内存单元大小为2个字节，偏移地址为 (bx) + 100</p>
</li>
</ul>
<h4 id="4-2-用-bx-idata-处理数组"><a href="#4-2-用-bx-idata-处理数组" class="headerlink" title="4.2 用[bx + idata]处理数组"></a>4.2 用[bx + idata]处理数组</h4><p>在上面处理大小写的程序中，因为要使用[bx]连续访问字符，只好使用两个循环。当我们可以使用[bx + idata]这种访问内存的方式时，可以用[bx]表示第一段连续字符的起始地址，用[5 + bx]表示第二段连续字符的起始地址。不过连个字符串的长度得是相等的，这个情况下才能一次循环。</p>
<p>代码如下：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">assume cs : code, ds : data</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">    db 'BaSiC'</span><br><span class="line">    db 'iNfOr'</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:  mov ax, data</span><br><span class="line">        mov ds, ax</span><br><span class="line">        mov bx, 0</span><br><span class="line"></span><br><span class="line">        mov cx, 5</span><br><span class="line">    s:  mov al, [bx]</span><br><span class="line">        and al, 11011111B</span><br><span class="line">        mov [bx], al</span><br><span class="line"></span><br><span class="line">        mov al, [5 + bx]</span><br><span class="line">        or al, 00100000B</span><br><span class="line">        mov [bx], al</span><br><span class="line"></span><br><span class="line">        inc bx</span><br><span class="line">        loop s</span><br><span class="line"></span><br><span class="line">        mov ax, 4c00h</span><br><span class="line">        int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></tbody></table></figure>

<h3 id="5-SI和DI"><a href="#5-SI和DI" class="headerlink" title="5 SI和DI"></a>5 SI和DI</h3><ul>
<li><p>si和di是X86中和bx功能相近的寄存器</p>
</li>
<li><p>si和di不能分成两个8位寄存器</p>
</li>
<li><p>等价指令：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mov bx, 0</span><br><span class="line">mov ax, [bx]</span><br><span class="line">&lt;=&gt;</span><br><span class="line">mov si, 0</span><br><span class="line">mov ax, [si]</span><br><span class="line">&lt;=&gt;</span><br><span class="line">mov di, 0</span><br><span class="line">mov ax, [di]</span><br></pre></td></tr></tbody></table></figure>



<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mov bx, 0</span><br><span class="line">mov ax, [bx + idata]</span><br><span class="line">&lt;=&gt;</span><br><span class="line">mov si, 0</span><br><span class="line">mov ax, [si + idata]</span><br><span class="line">&lt;=&gt;</span><br><span class="line">mov di, 0</span><br><span class="line">mov ax, [di + idata]</span><br></pre></td></tr></tbody></table></figure>


</li>
<li><p>应用：</p>
<ul>
<li><p>问题：定义两个字符串，’welcome to masm!’, ‘…………….’，将第一个字符串的内容复制到第二个字符串</p>
</li>
<li><p>代码：</p>
  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">assume cs : code, ds : data</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">    db 'welcome to masm!'</span><br><span class="line">    db '................' ;16</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:  mov ax, data</span><br><span class="line">        mov ds, ax</span><br><span class="line">        mov si, 0</span><br><span class="line">        mov di, 16</span><br><span class="line"></span><br><span class="line">        mov cx, 16</span><br><span class="line">    s:  mov al, [si]</span><br><span class="line">        mov [di], al</span><br><span class="line">        inc si</span><br><span class="line">        inc di</span><br><span class="line">        loop s</span><br><span class="line"></span><br><span class="line">    mov ax, 4c00h</span><br><span class="line">    int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
</li>
</ul>
<h3 id="6-bx-si-和-bx-di"><a href="#6-bx-si-和-bx-di" class="headerlink" title="6 [bx + si] 和 [bx + di]"></a>6 [bx + si] 和 [bx + di]</h3><ul>
<li><p>[bx + si]和[bx + di]都指明一个内存单元</p>
</li>
<li><p>[bx + si]偏移地址为：(bx) + (si)，[bx + di]偏移地址为：(bx) + (si)</p>
</li>
<li><p>等价指令：</p>
  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ax, [bx + si]</span><br><span class="line">&lt;=&gt;</span><br><span class="line">mov ax, [bx][si]</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h3 id="7-bx-si-idata-和-bx-di-idata"><a href="#7-bx-si-idata-和-bx-di-idata" class="headerlink" title="7 [bx + si + idata] 和 [bx + di + idata]"></a>7 [bx + si + idata] 和 [bx + di + idata]</h3><ul>
<li>[bx + si]和[bx + di]都指明一个内存单元</li>
<li>[bx + si]偏移地址为：(bx) + (si)，[bx + di]偏移地址为：(bx) + (di)</li>
</ul>
<h3 id="8-几种寻址方式"><a href="#8-几种寻址方式" class="headerlink" title="8 几种寻址方式"></a>8 几种寻址方式</h3><h4 id="8-1-寻址方式"><a href="#8-1-寻址方式" class="headerlink" title="8.1 寻址方式"></a>8.1 寻址方式</h4><ul>
<li>[idata] : 用一个常量来表示地址，可用于直接定位一个内存单元</li>
<li>[bx] : 用一个变量表示内存地址，可用于间接定位一个内存单元</li>
<li>[bx + idata] : 用一个变量和常量表示地址，可在一个其实地址的基础上用变量间接定位一个内存单元</li>
<li>[bx + si] : 用两个变量表示地址</li>
<li>[bx + si + idata] : 用连个变量和一个常量表示地址</li>
</ul>
<h4 id="8-2-一个嵌套循环的例子"><a href="#8-2-一个嵌套循环的例子" class="headerlink" title="8.2 一个嵌套循环的例子"></a>8.2 一个嵌套循环的例子</h4><p>在下面的代码中，我们将数据段中的每个单词转化为大写，使用[bx + si]的寻址方式，需要注意的是，在使用嵌套循环，当外层循环来到里层是，我们可以用栈空间（若用寄存器，容易产生冲突；若用内存单元，还需寻址，太麻烦）来存储外层循环的次数，在内存循环跳到外层循环时，将栈中存放的循环次数还给外层。</p>
<p>这种嵌套循环的大致结构如下：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">	mov cx, i_num ;外层循环次数为i_num</span><br><span class="line">i:	push cx ;用栈存储外层循环次数</span><br><span class="line">	...</span><br><span class="line">	外层循环操作</span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">	mov cx, j_num ;内层循环次数为j_num</span><br><span class="line">j:	...</span><br><span class="line">	内层循环操作</span><br><span class="line">	...</span><br><span class="line">	loop j</span><br><span class="line">	</span><br><span class="line">	...</span><br><span class="line">	外层循环操作</span><br><span class="line">	...</span><br><span class="line">	pop cx ;用栈弹出储存的外层循环次数，并给cx</span><br><span class="line">	loop i</span><br><span class="line">	</span><br></pre></td></tr></tbody></table></figure>



<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">assume cs : code, ds : data, ss : stack</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">    db 'ibm             '</span><br><span class="line">    db 'ddd             '</span><br><span class="line">    db 'dos             '</span><br><span class="line">    db 'vax             '</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">stack segment</span><br><span class="line">    dw 0, 0, 0, 0</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:  mov ax, data</span><br><span class="line">        mov ds, ax</span><br><span class="line">        mov ax, stack</span><br><span class="line">        mov ss, ax</span><br><span class="line">        mov sp, 8</span><br><span class="line">        mov bx, 0</span><br><span class="line">        </span><br><span class="line">        mov cx, 4</span><br><span class="line">    s1: push cx</span><br><span class="line">        mov si, 0</span><br><span class="line">        mov cx, 3</span><br><span class="line"></span><br><span class="line">    s2: mov al, [bx + si]</span><br><span class="line">        and al, 11011111b</span><br><span class="line">        mov [bx + si], al</span><br><span class="line">        inc si</span><br><span class="line">        loop s2</span><br><span class="line"></span><br><span class="line">        add bx, 16</span><br><span class="line">        pop cx</span><br><span class="line">        loop s1</span><br><span class="line"></span><br><span class="line">        mov ax, 4c00h</span><br><span class="line">        int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></tbody></table></figure>

<h2 id="八-数据处理的两个基本问题"><a href="#八-数据处理的两个基本问题" class="headerlink" title="八-数据处理的两个基本问题"></a>八-数据处理的两个基本问题</h2><ul>
<li>数据处理的两个基本问题：<ul>
<li>（1）处理的数据在什么地方</li>
<li>（2）要处理的数据有多长</li>
</ul>
</li>
<li>定义描述性符号 reg(寄存器) 和 sreg(段寄存器)：<ul>
<li>reg的集合包括：ax bx cx dx ah al bh bl ch cl dh dl sp bp si di</li>
<li>sreg的集合包括：ds ss cs es</li>
</ul>
</li>
</ul>
<h3 id="1-bx、si、di-和-bp"><a href="#1-bx、si、di-和-bp" class="headerlink" title="1 bx、si、di 和 bp"></a>1 bx、si、di 和 bp</h3><ul>
<li>在X86中，只有这四个寄存器可以用[…]指明内存单元</li>
<li>在[…]中，这4个寄存器可以单个出现，或只能以4中组合形式出现：bx和si、bx和di、bp和si、bp和di</li>
<li>只要在[…]中使用寄存器bp，默认段地址在ss中</li>
</ul>
<h3 id="2-机器指令处理的数据在什么地方"><a href="#2-机器指令处理的数据在什么地方" class="headerlink" title="2 机器指令处理的数据在什么地方"></a>2 机器指令处理的数据在什么地方</h3><ul>
<li>对数据处理的分类：读取、写入、运算</li>
<li>指令执行前一刻，数据所在位置：CPU内部、内存、端口</li>
</ul>
<img src="https://i.imgur.com/p28wEXS.png" height="150">

<h3 id="3-汇编语言中数据位置的表达"><a href="#3-汇编语言中数据位置的表达" class="headerlink" title="3 汇编语言中数据位置的表达"></a>3 汇编语言中数据位置的表达</h3><p>汇编中用3个概念表达数据的位置：</p>
<ul>
<li>（1）立即数(idata)：执行前在CPU指令缓存器中</li>
<li>（2）寄存器：执行前在寄存器中</li>
<li>（3）段地址(SA)和偏移地址(EA)：执行前在内存中</li>
</ul>
<h3 id="4-寻址方式"><a href="#4-寻址方式" class="headerlink" title="4 寻址方式"></a>4 寻址方式</h3><img src="https://i.imgur.com/mcxUcqO.png" height="600">

<h3 id="5-指令要处理的数据有多长"><a href="#5-指令要处理的数据有多长" class="headerlink" title="5 指令要处理的数据有多长"></a>5 指令要处理的数据有多长</h3><ul>
<li><p>X86CPU可处理两种尺寸的数据：byte 和 word</p>
</li>
<li><p>指明是字操作还是字节操作的方法：</p>
<ul>
<li><p>（1）通过寄存器指明</p>
</li>
<li><p>（2）通过操作符 X ptr指明</p>
<ul>
<li><p>word ptr指明字</p>
  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov word ptr ds:[0], 1</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>byte ptr指明字节</p>
  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov byte ptr ds:[0], 1</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
</li>
<li><p>（3）默认操作数据长度，如push、pop是字操作</p>
</li>
</ul>
</li>
</ul>
<h3 id="6-寻址方式的综合应用"><a href="#6-寻址方式的综合应用" class="headerlink" title="6 寻址方式的综合应用"></a>6 寻址方式的综合应用</h3><p>在访问一个结构体时：（以bx、si、idata举例）</p>
<ul>
<li><p>bx定位整个结构体：</p>
  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[bx]</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>idata定位结构体中某一数据项：</p>
  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[bx + idata]</span><br><span class="line">&lt;=&gt;</span><br><span class="line">[bx].idata</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>si定位结构体中某一数据项中某一个元素：</p>
  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[bx + idata + si]</span><br><span class="line">[bx].idata[si]</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h3 id="7-div指令"><a href="#7-div指令" class="headerlink" title="7 div指令"></a>7 div指令</h3><ul>
<li><p>注意：</p>
<ul>
<li>除数：有8位和16位两种，在一个reg或内存中</li>
<li>被除数：<ul>
<li>除数8位，被除数16位：默认AX中</li>
<li>除数16位，被除数32位：高16位DX，低16位AX</li>
</ul>
</li>
<li>结果：<ul>
<li>除数8位：AL存商，AH存余</li>
<li>除数16位：AX存商，DX存余</li>
</ul>
</li>
</ul>
</li>
<li><p>指令格式：</p>
  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">div reg</span><br><span class="line">div 内存单元</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>eg:</p>
  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">div byte ptr ds:[0] </span><br><span class="line">; (al) = (ax) // ((ds)*16 + 0)</span><br><span class="line">; (ah) = (ax) %  ((ds)*16 + 0)</span><br><span class="line"></span><br><span class="line">div word ptr ds:[0]</span><br><span class="line">; (ax) = ((dx)*10000H + (ax)) / ((ds)*16 + 0)</span><br><span class="line">; (dx) = ((dx)*10000H + (ax)) / ((ds)*16 + 0)</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h3 id="8-伪指令dd"><a href="#8-伪指令dd" class="headerlink" title="8 伪指令dd"></a>8 伪指令dd</h3><ul>
<li>dd定义双字型（double word）数据</li>
<li>dw定义字型数据</li>
<li>db定义字节型数据</li>
</ul>
<h3 id="9-dup"><a href="#9-dup" class="headerlink" title="9 dup"></a>9 dup</h3><ul>
<li><p>dup是一个操作符，于db、dw、dd等配合使用，用于重复定义数据</p>
</li>
<li><p>eg:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">db 3 dup (0)</span><br><span class="line">&lt;=&gt; </span><br><span class="line">db 0, 0, 0</span><br><span class="line"></span><br><span class="line">db 3 dup (0, 1, 2)</span><br><span class="line">&lt;=&gt;</span><br><span class="line">db 0, 1, 2, 0, 1, 2, 0, 1, 2</span><br><span class="line"></span><br><span class="line">db 3 dup ('abc', 'ABC')</span><br><span class="line">&lt;=&gt;</span><br><span class="line">db 'abcABCabcABCabcABC'</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h2 id="九-转移指令的原理"><a href="#九-转移指令的原理" class="headerlink" title="九-转移指令的原理"></a>九-转移指令的原理</h2><ul>
<li>转移指令：可以修改IP，或同时修改CS和IP的指令统称。转移指令可以控制CPU执行内存中某处代码的指令。</li>
<li>X86转移行为的分类：<ul>
<li>段间转移：同时修改CS和IP</li>
<li>段内转移：只修改CS和IP<ul>
<li>短转移：IP修改范围位-128~127</li>
<li>近转移：IP修改范围为-32767~32767</li>
</ul>
</li>
</ul>
</li>
<li>X86转移指令的分类：<ul>
<li>无条件转移指令（eg : jmp）</li>
<li>条件转移指令</li>
<li>循环指令（eg : loop）</li>
<li>过程</li>
<li>中断</li>
</ul>
</li>
</ul>
<h3 id="1-操作符-offset"><a href="#1-操作符-offset" class="headerlink" title="1 操作符 offset"></a>1 操作符 offset</h3><ul>
<li><p>功能：取得标号的偏移地址</p>
</li>
<li><p>指令格式：</p>
  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">offset 标号</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h3 id="2-jmp指令"><a href="#2-jmp指令" class="headerlink" title="2 jmp指令"></a>2 jmp指令</h3><ul>
<li>无条件转移指令，可以同时修改CS和IP，也可以只修改IP</li>
<li>给出两种信息：<ul>
<li>（1）转移的目的地址</li>
<li>（2）转移的距离（段间转移、段内短转移、段内近转移）</li>
</ul>
</li>
</ul>
<h4 id="2-1-根据位移进行转移的jmp指令"><a href="#2-1-根据位移进行转移的jmp指令" class="headerlink" title="2.1 根据位移进行转移的jmp指令"></a>2.1 根据位移进行转移的jmp指令</h4><p>对应机器码中只包含转移位移</p>
<ul>
<li><p>段内短转移：</p>
<ul>
<li><p>指令格式：</p>
  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmp short 标号</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>实际功能：(IP) = (IP) + 8位位移</p>
</li>
<li><p>8位位移 = 标号处地址 - jmp指令后第一个字节地址</p>
</li>
<li><p>short指明位移位8位，范围为-128~127</p>
</li>
<li><p>8为位移由编译程序在编译时算出</p>
</li>
</ul>
</li>
<li><p>段内近转移：</p>
<ul>
<li><p>指令格式：</p>
  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmp near ptr 标号</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>实际功能：(IP) = (IP) + 16位位移</p>
</li>
<li><p>16位位移 = 标号处地址 - jmp指令后第一个字节地址</p>
</li>
<li><p>near ptr指明位移16位，范围为-32768~32767</p>
</li>
<li><p>16为位移由编译程序在编译时算出</p>
</li>
</ul>
</li>
</ul>
<h4 id="2-2-转移目的地址在指令中的jmp指令"><a href="#2-2-转移目的地址在指令中的jmp指令" class="headerlink" title="2.2 转移目的地址在指令中的jmp指令"></a>2.2 转移目的地址在指令中的jmp指令</h4><p>对应机器码中包含转移位移和目的地址</p>
<ul>
<li><p>指令格式：</p>
  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmp far ptr 标号</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>实现段间转移（远转移）</p>
</li>
<li><p>功能：修改CS和IP，(CS) = 标号所在段的段地址，(IP) = 标号所在段中的偏移地址</p>
</li>
<li><p>far ptr用标号所在段的段地址和偏移地址指明了修改CS和IP</p>
</li>
</ul>
<h4 id="2-3-转移地址在寄存器中的jmp指令"><a href="#2-3-转移地址在寄存器中的jmp指令" class="headerlink" title="2.3 转移地址在寄存器中的jmp指令"></a>2.3 转移地址在寄存器中的jmp指令</h4><ul>
<li><p>指令格式：</p>
  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmp 16位reg</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>功能：(IP) = (16位reg)</p>
</li>
</ul>
<h4 id="2-4-转移地址在内存中的jmp指令"><a href="#2-4-转移地址在内存中的jmp指令" class="headerlink" title="2.4 转移地址在内存中的jmp指令"></a>2.4 转移地址在内存中的jmp指令</h4><ul>
<li><p>段内转移：</p>
<ul>
<li><p>指令格式：</p>
  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmp word ptr 内存单元地址</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>功能：(IP) = (内存单元地址)</p>
</li>
</ul>
</li>
<li><p>段间转移：</p>
<ul>
<li><p>指令格式：</p>
  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmp dword ptr 内存单元地址</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>功能：(CS) = (内存单元地址 + 2), (IP) = (内存单元地址)</p>
</li>
</ul>
</li>
</ul>
<h3 id="3-jcxz-指令"><a href="#3-jcxz-指令" class="headerlink" title="3 jcxz 指令"></a>3 jcxz 指令</h3><ul>
<li><p>有条件转移指令，所有有条件转移指令都是短转移，IP修改范围为-128~127</p>
</li>
<li><p>对应机器码中包含转移的位移，而不是目的地址</p>
</li>
<li><p>指令格式：</p>
  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jcxz 标号 ;如果(cx) = 0，转移到标号处执行</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>功能：(cx) = 0时，(IP) = (IP) + 8为位移；(cx) != 0时，啥也不做</p>
</li>
<li><p>8位位移 = 标号处地址 - jcxz指令后第一个字节地址</p>
</li>
<li><p>short指明位移位8位，范围为-128~127</p>
</li>
<li><p>8为位移由编译程序在编译时算出</p>
</li>
</ul>
<h3 id="4-loop-指令"><a href="#4-loop-指令" class="headerlink" title="4 loop 指令"></a>4 loop 指令</h3><ul>
<li><p>循环指令，所有的循环指令都是短转移指令，IP的修改范围为-128~127</p>
</li>
<li><p>对应机器码中包含转移的位移，而不是目的地址</p>
</li>
<li><p>指令格式：</p>
  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loop 标号 ; (cx) = (cx) - 1，cx != 0，转移到标号处</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>功能：</p>
<ul>
<li>（1）(cx) = (cx) - 1</li>
<li>（2）若(cx) != 0，(IP) = (IP) + 8位位移</li>
<li>8位位移 = 标号处地址 - loop指令后第一个字节地址</li>
<li>short指明位移位8位，范围为-128~127</li>
<li>8为位移由编译程序在编译时算出</li>
</ul>
</li>
</ul>
<h2 id="十-CALL-和-RET-指令"><a href="#十-CALL-和-RET-指令" class="headerlink" title="十-CALL 和 RET 指令"></a>十-CALL 和 RET 指令</h2><p>call 和 ret 指令都是转移指令，都修改IP或同时修改CS 和 IP，经常被共同使用用来实现子程序的设计。</p>
<h3 id="1-ret-和-retf"><a href="#1-ret-和-retf" class="headerlink" title="1 ret 和 retf"></a>1 ret 和 retf</h3><ul>
<li><p>ret</p>
<ul>
<li><p>指令格式：</p>
  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ret</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>用栈中的数据修改IP，实现近转移</p>
</li>
<li><p>执行命令时的2步操作:</p>
<ul>
<li>(1) (IP) = ((ss) * 16 + (sp))</li>
<li>(2) (sp) = (sp) + 2</li>
</ul>
</li>
<li><p>等价指令：</p>
  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pop ip</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
</li>
<li><p>retf</p>
<ul>
<li><p>指令格式：</p>
  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">retf</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>用栈中的数据修改CS和IP，实现远转移</p>
</li>
<li><p>执行命令时的4步操作：</p>
<ul>
<li>(1) (IP) = ((ss) * 16 + (sp))</li>
<li>(2) (sp)  = (sp) + 2</li>
<li>(3) (CS) = ((ss) * 16 + (sp))</li>
<li>(4) (sp) = (sp) + 2</li>
</ul>
</li>
<li><p>等价指令：</p>
  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pop ip</span><br><span class="line">pop cs</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
</li>
</ul>
<h3 id="2-call指令"><a href="#2-call指令" class="headerlink" title="2 call指令"></a>2 call指令</h3><ul>
<li>call指令不能实现段转移，此外都和jmp使用原理大致相同</li>
<li>执行指令时的2步操作：<ul>
<li>（1）将当前的IP后CS和IP压入栈中</li>
<li>（2）转移</li>
</ul>
</li>
</ul>
<h4 id="2-1-依据位移进行转移的call指令"><a href="#2-1-依据位移进行转移的call指令" class="headerlink" title="2.1 依据位移进行转移的call指令"></a>2.1 依据位移进行转移的call指令</h4><ul>
<li><p>指令格式：</p>
  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call 标号 ;将当前IP压栈后，转到标号处执行指令</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>执行指令时的2步操作：</p>
<ul>
<li><p>（1）(sp) = (sp) - 2 </p>
<p>  ​		  ((ss) * 16 + (sp)) = (IP)</p>
</li>
<li><p>（2）(IP) = (IP) + 16位位移</p>
</li>
</ul>
</li>
<li><p>16位位移 = 标号处地址 - call指令后的第一个字节的地址</p>
</li>
<li><p>16位位移的范围为-32768 - 32767，用补码表示</p>
</li>
<li><p>16位位移由编译程序在编译时算出</p>
</li>
<li><p>等价指令：</p>
  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push ip</span><br><span class="line">jmp near ptr 标号</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h4 id="2-2-转移目的地址在指令中的call指令"><a href="#2-2-转移目的地址在指令中的call指令" class="headerlink" title="2.2 转移目的地址在指令中的call指令"></a>2.2 转移目的地址在指令中的call指令</h4><ul>
<li><p>指令格式：</p>
  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call far ptr 标号 ;实现段间转移</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>执行指令时的2步操作：</p>
<ul>
<li><p>（1）(sp) = (sp) - 2</p>
<p>  ​		  ((ss) * 16 + (sp)) = (CS)</p>
<p>  ​          (sp) = (sp) - 2</p>
<p>  ​		  ((ss) * 16 + (sp)) = (IP)</p>
</li>
<li><p>（2）(CS) = 标号所在段的段地址</p>
<p>  ​		   (IP) = 标号所在段的偏移地址</p>
</li>
</ul>
</li>
<li><p>等价指令：</p>
  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">push cs</span><br><span class="line">push ip</span><br><span class="line">jmp far ptr 标号</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h4 id="2-3-转移地址在寄存器中的call指令"><a href="#2-3-转移地址在寄存器中的call指令" class="headerlink" title="2.3 转移地址在寄存器中的call指令"></a>2.3 转移地址在寄存器中的call指令</h4><ul>
<li><p>指令格式：</p>
  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call 16位reg</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>指令执行时的2步操作：</p>
<ul>
<li><p>（1）(sp) = (sp) - 2</p>
<p>  ​          ((ss) * 16 + (sp)) = (IP)</p>
</li>
<li><p>（2）(IP)  = (16位reg)</p>
</li>
</ul>
</li>
<li><p>等价指令：</p>
  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push ip</span><br><span class="line">jmp 16位reg</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h4 id="2-4-转移地址在内存中的call指令"><a href="#2-4-转移地址在内存中的call指令" class="headerlink" title="2.4 转移地址在内存中的call指令"></a>2.4 转移地址在内存中的call指令</h4><ul>
<li><p>call word ptr</p>
<ul>
<li><p>指令格式：</p>
  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call word ptr 内存单元地址</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>等价指令：</p>
  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push ip</span><br><span class="line">jmp word ptr 内存单元地址</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
</li>
<li><p>call dword ptr 内存单元地址</p>
<ul>
<li><p>指令格式：</p>
  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call dword ptr 内存单元地址</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>等价指令：</p>
  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">push cs </span><br><span class="line">push ip</span><br><span class="line">jmp dword ptr 内存单元地址</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
</li>
</ul>
<h3 id="3-call-和-ret-的配合使用"><a href="#3-call-和-ret-的配合使用" class="headerlink" title="3 call 和 ret 的配合使用"></a>3 call 和 ret 的配合使用</h3><ul>
<li><p>子程序：具有一定功能的程序段，用call指令执行，ret指令返回</p>
</li>
<li><p>子程序的框架：</p>
  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">标号:</span><br><span class="line">	指令</span><br><span class="line">	ret</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>具有子程序的源程序的框架：</p>
  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">assume cs : code</span><br><span class="line">code segment</span><br><span class="line">main:	:</span><br><span class="line">		:</span><br><span class="line">		call sub</span><br><span class="line">		:</span><br><span class="line">		:</span><br><span class="line">		mov ax, 4c00h</span><br><span class="line">		int 21h</span><br><span class="line">		</span><br><span class="line">sub1:	:</span><br><span class="line">		:</span><br><span class="line">		call sub2</span><br><span class="line">		:</span><br><span class="line">		:</span><br><span class="line">		ret</span><br><span class="line">		</span><br><span class="line">sub2:	:</span><br><span class="line">		:</span><br><span class="line">		:ret</span><br><span class="line">code ends</span><br><span class="line">end main</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h3 id="4-mul-指令"><a href="#4-mul-指令" class="headerlink" title="4 mul 指令"></a>4 mul 指令</h3><ul>
<li><p>mul时乘法指令</p>
</li>
<li><p>注意：</p>
<ul>
<li>（1）两个相乘的数：<ul>
<li>两个相乘的数，都是8位或16位</li>
<li>8位：一个默认在AL中，另一个在8位reg或内存字节单元中</li>
<li>16位：一个默认在AX中，另一在16位reg或内存字单元中</li>
</ul>
</li>
<li>（2）结果：<ul>
<li>8位乘法：默认AX中</li>
<li>16位乘法：高位DX，低位AX</li>
</ul>
</li>
</ul>
</li>
<li><p>指令格式：</p>
  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mul reg</span><br><span class="line">mul 内存单元 ; 内存单元可以用不同的寻址方式给出</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h3 id="5-模块化程序设计及其问题"><a href="#5-模块化程序设计及其问题" class="headerlink" title="5 模块化程序设计及其问题"></a>5 模块化程序设计及其问题</h3><p>call和ret指令共同支持了汇编语言编程中的模块化设计，由此可以实现多个相互联系、功能独立的子程序来解决一个复杂的问题。</p>
<h4 id="5-1-参数和结果传递的问题"><a href="#5-1-参数和结果传递的问题" class="headerlink" title="5.1 参数和结果传递的问题"></a>5.1 参数和结果传递的问题</h4><p>用寄存器存储子程序的参数和返回值，是最常见的方法。调用者将参数送入参数寄存器，从结果寄存器中取得返回值；子程序从参数寄存器中取到参数，将返回值送入结果寄存器。</p>
<p>eg：计算data段中第一组数据的3次方结果保存在后面一组dword单元中。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">assume cs : code</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">    dw 1, 2, 3, 4, 5, 6, 7, 8</span><br><span class="line">    dd 8 dup (0)</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:  mov ax, data</span><br><span class="line">        mov ds, ax</span><br><span class="line">        mov si, 0 ;si用于索引源地址</span><br><span class="line">        mov di, 16 ;di用于索引目的地址</span><br><span class="line"></span><br><span class="line">        mov cx, 8</span><br><span class="line">    s:  mov bx, [si]</span><br><span class="line">        call cube</span><br><span class="line">        mov [di], ax</span><br><span class="line">        mov [di].2, dx</span><br><span class="line">        add si, 2</span><br><span class="line">        add di, 4</span><br><span class="line">        loop s</span><br><span class="line"></span><br><span class="line">        mov ax, 4c00h</span><br><span class="line">        int 21h</span><br><span class="line"></span><br><span class="line">cube:   mov ax, bx</span><br><span class="line">        mul bx</span><br><span class="line">        mul bx</span><br><span class="line">        ret</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></tbody></table></figure>

<h4 id="5-2-批量数据的传递"><a href="#5-2-批量数据的传递" class="headerlink" title="5.2 批量数据的传递"></a>5.2 批量数据的传递</h4><p>当需要传递多个数据时，我们将批量数据放在内存中，将数据所在内存空间的首地址放入寄存器中，传递给需要的子程序。</p>
<p>eg：将data段的字符串改为大写。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">assume cs : code</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">    db 'conversation' ;12个字节</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:  mov ax, data</span><br><span class="line">        mov ds, ax</span><br><span class="line">        mov si, 0 ;si用于索引字符串的每个字符</span><br><span class="line">        mov cx, 12</span><br><span class="line">        call capital</span><br><span class="line">        mov ax, 4c00h</span><br><span class="line">        int 21h</span><br><span class="line">        </span><br><span class="line">capital:and byte ptr [si], 11011111b</span><br><span class="line">        inc si</span><br><span class="line">        loop capital</span><br><span class="line">        ret</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></tbody></table></figure>

<h4 id="5-3-寄存器冲突的问题"><a href="#5-3-寄存器冲突的问题" class="headerlink" title="5.3 寄存器冲突的问题"></a>5.3 寄存器冲突的问题</h4><p>当寄存器reg在主程序中用于功能1，而在子程序中用于功能2，主程序和子程序都调用该寄存器，并且用于不同的功能，产生寄存器冲突。我们可以用栈来存储主程序中寄存器的值，在子程序返回时再将值栈出。</p>
<p>eg：将data段中的每个字符串改为大写。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">assume cs : code</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">    db 'worl', 0 ;每个算上0，5byte</span><br><span class="line">    db 'unix', 0</span><br><span class="line">    db 'wind', 0</span><br><span class="line">    db 'good', 0</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:  mov ax, data</span><br><span class="line">        mov ds, ax</span><br><span class="line">        mov bx, 0</span><br><span class="line">        mov cx, 4</span><br><span class="line"></span><br><span class="line">    s:  mov si, bx</span><br><span class="line">        call capital</span><br><span class="line">        add bx, 5</span><br><span class="line">        loop s</span><br><span class="line"></span><br><span class="line">        mov ax, 4c00h</span><br><span class="line">        int 21h</span><br><span class="line"></span><br><span class="line">capital:</span><br><span class="line">        push cx ;存值</span><br><span class="line">    s0: mov cl, [si]</span><br><span class="line">        mov ch, 0</span><br><span class="line">        jcxz ok</span><br><span class="line">        and byte ptr [si], 11011111b</span><br><span class="line">        inc si</span><br><span class="line">        jmp short s0</span><br><span class="line"></span><br><span class="line">    ok: pop cx ;还值</span><br><span class="line">        ret</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></tbody></table></figure>

<h2 id="十一-标志寄存器"><a href="#十一-标志寄存器" class="headerlink" title="十一-标志寄存器"></a>十一-标志寄存器</h2><ul>
<li>标志(flag)寄存器的3种作用：<ul>
<li>（1）用来存储相关指令的某些执行结果</li>
<li>（2）用来为CPU执行相关的指令提供行为依据</li>
<li>（3）用来控制CPU的相关工作方式</li>
</ul>
</li>
<li>X86标志寄存器有16位，其中存储的信息通常称为程序状态字(PSW)</li>
<li>flag寄存器按位起作用，每一位都有专门的含义</li>
<li>X86寄存器结构：</li>
<li><img src="https://i.imgur.com/YH94Z7m.png" height="100"></li>
<li>影响flag寄存器的大多时运算指令，传送指令一般不影响</li>
</ul>
<h3 id="1-ZF标志"><a href="#1-ZF标志" class="headerlink" title="1 ZF标志"></a>1 ZF标志</h3><ul>
<li>第6位，零标志位</li>
<li>功能：记录相关指令执行后，结果是否为0。为0，zf=1；不为0，zf=0</li>
</ul>
<h3 id="2-PF标志"><a href="#2-PF标志" class="headerlink" title="2 PF标志"></a>2 PF标志</h3><ul>
<li>第2位，奇偶标志位</li>
<li>功能：记录相关指令执行后，结果所有bit位1的个数是否为偶数。是偶数，pf=1，不是偶数pf=0</li>
</ul>
<h3 id="3-SF标志"><a href="#3-SF标志" class="headerlink" title="3 SF标志"></a>3 SF标志</h3><ul>
<li>第7位，符号标志位</li>
<li>功能：记录相关指令执行后，结果是否为负。负，sf=1；非负，sf=0</li>
</ul>
<h3 id="4-CF标志"><a href="#4-CF标志" class="headerlink" title="4 CF标志"></a>4 CF标志</h3><ul>
<li>第0位，进位标志位</li>
<li>功能：在进行<strong>无符号运算</strong>时，记录运算结果的最高有效位想更高位的进位值，或从更高位的借位值</li>
</ul>
<h3 id="5-OF标志"><a href="#5-OF标志" class="headerlink" title="5 OF标志"></a>5 OF标志</h3><ul>
<li>第11位，溢出标志位</li>
<li>功能：在进行<strong>有符号运算</strong>时，记录运算结果是否发生了溢出。发生溢出，of=1；没有溢出，of=0</li>
</ul>
<h3 id="6-adc指令"><a href="#6-adc指令" class="headerlink" title="6 adc指令"></a>6 adc指令</h3><ul>
<li><p>带进位加法指令，利用了CF进位上记录的进位值</p>
</li>
<li><p>指令格式:</p>
  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adc 操作对象1, 操作对象2</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>功能：$操作对象1 = 操作对象1 + 操作对象2 + CF$</p>
</li>
<li><p>配合使用add指令和adc指令，可以对更大的数据进行加法运算</p>
  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">;编程，计算1EF0001000h + 2010001EF0h</span><br><span class="line">;结果存于ax:高16位，bx:次高16位，cx:低16位</span><br><span class="line"></span><br><span class="line">assume cs : code</span><br><span class="line">code segment</span><br><span class="line">start:  </span><br><span class="line">        mov ax, 001eh</span><br><span class="line">        mov bx, 0f000h</span><br><span class="line">        mov cx, 1000h</span><br><span class="line"></span><br><span class="line">        add cx, 1ef0h</span><br><span class="line">        adc bx, 1000h</span><br><span class="line">        adc ax, 0020h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h3 id="7-sbb指令"><a href="#7-sbb指令" class="headerlink" title="7 sbb指令"></a>7 sbb指令</h3><ul>
<li><p>带借位减法指令，利用了CF上记录的借位值</p>
</li>
<li><p>指令格式：</p>
  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sbb 操作对象1, 操作对象2</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>功能：$操作对象1 = 操作对象1 - 操作对象2 - CF$</p>
</li>
<li><p>配合使用sub指令和sbb指令，可以对更大的数据进行减法运算</p>
</li>
</ul>
<h3 id="8-cmp指令"><a href="#8-cmp指令" class="headerlink" title="8 cmp指令"></a>8 cmp指令</h3><ul>
<li><p>比较指令，功能相当于减法指令，但不保存运算结果</p>
</li>
<li><p>指令格式：</p>
  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmp 操作对象1, 操作对象2</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>功能：计算 操作对象1 - 操作对象2，不保存结果，根据计算记过对flag寄存器进行设置</p>
</li>
<li><p>cmp指令后，flag寄存器相关标志位发生改变，由此判断两个数的大小</p>
</li>
</ul>
<h3 id="9-检测比较结果的条件转移指令"><a href="#9-检测比较结果的条件转移指令" class="headerlink" title="9 检测比较结果的条件转移指令"></a>9 检测比较结果的条件转移指令</h3><p>cmp指令可以进行无符号数和有符号数的比较，根据比较结果，一些指令可以实现条件转移。</p>
<ul>
<li><p>根据无符号数比较结果进行转移的条件转移指令</p>
  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">;指令               含义            检测的相关标志位</span><br><span class="line">je;(jump equal)     等于则转移      zf = 1</span><br><span class="line">jne;(jump not equal)不等于则转移    zf = 0</span><br><span class="line">jb;(jump below)     低于则转移      cf = 1</span><br><span class="line">jnb;(jump not below)不低于则转移    cf = 0</span><br><span class="line">ja;(jump above)     高于则转移      cf = 0 and zf = 0</span><br><span class="line">jna;(jump not above)不高于则转移    cf = 1 and cf = 1</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>根据比较结果的条件转移指令，只根据检测的相关标志位来判断是否跳转，当和cmp配合使用时，可以通过逻辑来判断，而无需费时去考虑相关标志位的值</p>
</li>
<li><p>eg：统计数据段中数值位8的字节的个数，用ax保存结果</p>
  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">assume cs : code</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">    db 8, 11, 8, 1, 8, 5, 63, 38</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:  </span><br><span class="line">        mov ax, data</span><br><span class="line">        mov ds, ax</span><br><span class="line">        mov bx, 0</span><br><span class="line">        mov ax, 0</span><br><span class="line"></span><br><span class="line">        mov cx, 8</span><br><span class="line">    s:  cmp byte ptr [bx], 8</span><br><span class="line">        jne next</span><br><span class="line">        inc ax</span><br><span class="line">    next:</span><br><span class="line">        inc bx</span><br><span class="line">        loop s</span><br><span class="line"></span><br><span class="line">        mov ax, 4c00h</span><br><span class="line">        int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h3 id="10-DF标志和串传送指令"><a href="#10-DF标志和串传送指令" class="headerlink" title="10 DF标志和串传送指令"></a>10 DF标志和串传送指令</h3><h4 id="10-1-DF标志"><a href="#10-1-DF标志" class="headerlink" title="10.1 DF标志"></a>10.1 DF标志</h4><ul>
<li>第10位，方向标志位</li>
<li>功能：再串处理指令中，控制每次操作后si、di的增减。df=0，每次操作后si、di递增；df=1，每次操作后si、di递减</li>
</ul>
<h4 id="10-2-串传送指令"><a href="#10-2-串传送指令" class="headerlink" title="10.2 串传送指令"></a>10.2 串传送指令</h4><ul>
<li><p>传送字节</p>
<ul>
<li><p>指令格式：</p>
  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">movsb</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>功能：将ds:si指向的内存单元的字节送入es:di中，根据标志寄存器df位的值，将si和di递增或递减</p>
</li>
<li><p>指令执行时的2步操作：</p>
  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">;(1)</span><br><span class="line">((es) * 16 + (di)) = ((ds) * 16 + (si))</span><br><span class="line">;(2)</span><br><span class="line">df = 0:</span><br><span class="line">		(si) = (si) + 1</span><br><span class="line">		(di) = (di) + 1</span><br><span class="line">df = 1:</span><br><span class="line">		(si) = (si) - 1</span><br><span class="line">		(di) = (di) - 1</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
</li>
<li><p>传送字</p>
<ul>
<li><p>指令格式：</p>
  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">movsw</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>功能：将ds:si指向的内存单元的字送入es:di中，根据标志寄存器df位的值，将si和di递增2或递减2</p>
</li>
</ul>
</li>
</ul>
<h4 id="10-3-串传送指令与rep指令的配合"><a href="#10-3-串传送指令与rep指令的配合" class="headerlink" title="10.3 串传送指令与rep指令的配合"></a>10.3 串传送指令与rep指令的配合</h4><ul>
<li><p>指令格式：</p>
  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rep movsb</span><br><span class="line">rep movsw</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>等价指令：</p>
  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">rep movsb </span><br><span class="line">&lt;=&gt;</span><br><span class="line">s:movsb</span><br><span class="line">  loop s</span><br><span class="line">  </span><br><span class="line">rep movsw</span><br><span class="line">&lt;=&gt;</span><br><span class="line">s:movsw</span><br><span class="line">  loop s</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h4 id="10-4-对df进行设置："><a href="#10-4-对df进行设置：" class="headerlink" title="10.4 对df进行设置："></a>10.4 对df进行设置：</h4><ul>
<li><p>cld指令：</p>
  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cld ;将寄存器的df位置0，递减</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>std指令：</p>
  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std ;将寄存器的df位值1，递增</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h4 id="10-5-应用举例"><a href="#10-5-应用举例" class="headerlink" title="10.5 应用举例"></a>10.5 应用举例</h4><ul>
<li><p>eg：将data段中的第一个字符串复制到后面的空间</p>
  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">assume cs : code</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">    db 'Welcome to masm!'</span><br><span class="line">    db 16 dup (0)</span><br><span class="line">data ends</span><br><span class="line">code segment</span><br><span class="line">start:  </span><br><span class="line">        ;ds:si指向源地址</span><br><span class="line">        mov ax, data</span><br><span class="line">        mov ds, ax</span><br><span class="line">        mov si, 0</span><br><span class="line">        ;es:di指向目的地址</span><br><span class="line">        mov es, ax</span><br><span class="line">        mov di, 16</span><br><span class="line">        </span><br><span class="line">        mov cx, 16 ;循环16次</span><br><span class="line">        ;正向传输</span><br><span class="line">        cld</span><br><span class="line">        rep movsb</span><br><span class="line"></span><br><span class="line">        mov ax, 4c00h</span><br><span class="line">        int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h3 id="11-pushf-和-popf"><a href="#11-pushf-和-popf" class="headerlink" title="11 pushf 和 popf"></a>11 pushf 和 popf</h3><ul>
<li>pushf：将标志寄存器的值压入栈中</li>
<li>popf：从栈中弹出标志寄存器的值</li>
</ul>
<h2 id="十二-内中断"><a href="#十二-内中断" class="headerlink" title="十二-内中断"></a>十二-内中断</h2><h3 id="1-中断过程"><a href="#1-中断过程" class="headerlink" title="1 中断过程"></a>1 中断过程</h3><ul>
<li>中断信息：要求CPU马上进行某种处理，并向所要进行的处理提供必备参数的通知信息</li>
<li>中断：CPU不再接着向下执行指令，而是转去处理中断信息</li>
<li>中断源：造成中断的事件，产生中断信息</li>
<li>中断类型码：不同中断源对应的字节型数据</li>
<li>中断处理程序：用来处理中断信息的程序</li>
<li>中断向量：中断处理程序的入口地址</li>
<li>中断向量表：存储中断向量的列表</li>
</ul>
<p>一个中断过程如下：</p>
<ol>
<li>从中断信息中获得中断类型码</li>
<li>标志寄存器值入栈（中断过程改变标志寄存器值）</li>
<li>设置标志寄存器中的第8位TF和第9位IF的值为0</li>
<li>CS的内容入栈</li>
<li>IP的内容入栈</li>
<li>从内存地址为 $中断类型码 * 4$ 和 $中断类型码 * 4 + 2$的两个字单元中读取中断处理程序的入口地址设置IP和CS</li>
</ol>
<p>中断过程的简洁描述：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 取得中断类型码N</span><br><span class="line">2. pushf</span><br><span class="line">3. TF = 0, IF = 0</span><br><span class="line">4. push CS</span><br><span class="line">5. push IP</span><br><span class="line">6. (IP) = (N * 4) (CS) = (N * 4 + 2)</span><br></pre></td></tr></tbody></table></figure>

<h3 id="2-中断处理程序和iret指令"><a href="#2-中断处理程序和iret指令" class="headerlink" title="2 中断处理程序和iret指令"></a>2 中断处理程序和iret指令</h3><ul>
<li><p>中断处理程序编写步骤：</p>
<ul>
<li>（1）保存用到的寄存器</li>
<li>（2）处理中断</li>
<li>（3）回复用到的寄存器</li>
<li>（4）用iret指令返回</li>
</ul>
</li>
<li><p>iret指令的等价指令：</p>
  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pop ip</span><br><span class="line">pop cs</span><br><span class="line">pop f</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h3 id="3-0号中断程序编写"><a href="#3-0号中断程序编写" class="headerlink" title="3 0号中断程序编写"></a>3 0号中断程序编写</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">;编写0号中断程序</span><br><span class="line">;名称：do0</span><br><span class="line">;功能：发生除法溢出时，在屏幕显示："overflow!"</span><br><span class="line">;程序入口地址：0000:0200</span><br><span class="line">;0号表项地址：0:0，0:0字单元存放偏移地址，0:2字单元存放地址单元</span><br><span class="line"></span><br><span class="line">assume cs : code</span><br><span class="line">code segment</span><br><span class="line">    start:</span><br><span class="line">        ;安装do0程序</span><br><span class="line">        ;ds:si指向源地址</span><br><span class="line">        mov ax, cs</span><br><span class="line">        mov ds, ax</span><br><span class="line">        mov si, offset do0</span><br><span class="line">        ;es:di指向目的地址</span><br><span class="line">        mov ax, 0</span><br><span class="line">        mov es, ax</span><br><span class="line">        mov di, 200h</span><br><span class="line">        ;cx存放程序长度</span><br><span class="line">        mov cx, offset do0end - offset do0</span><br><span class="line">        ;正向传输</span><br><span class="line">        cld</span><br><span class="line">        rep movsb</span><br><span class="line"></span><br><span class="line">        ;设置中断向量表</span><br><span class="line">        mov ax, 0</span><br><span class="line">        mov es, ax</span><br><span class="line">        mov word ptr es:[0 * 4], 200h</span><br><span class="line">        mov word ptr es:[0 * 4 + 2], 0</span><br><span class="line"></span><br><span class="line">        mov ax, 1000h</span><br><span class="line">        mov bx, 1</span><br><span class="line">        div bx</span><br><span class="line"></span><br><span class="line">        mov ax, 4c00h</span><br><span class="line">        int 21h</span><br><span class="line">    do0:    </span><br><span class="line">        ;再程序中存入显示字符</span><br><span class="line">        jmp short do0start</span><br><span class="line">        db "overflow!"</span><br><span class="line">    do0start:</span><br><span class="line">        ;显示字符串"overflow!"</span><br><span class="line">        ;ds:si指向字符串</span><br><span class="line">        mov ax, cs</span><br><span class="line">        mov ds, ax</span><br><span class="line">        mov si, 202h</span><br><span class="line">        ;设置显示位置</span><br><span class="line">        mov ax, 0b800h</span><br><span class="line">        mov es, ax</span><br><span class="line">        mov di, 12 * 160 + 36 * 2</span><br><span class="line"></span><br><span class="line">        mov cx, 9</span><br><span class="line">    s:  mov al, [si]</span><br><span class="line">        mov es:[di], al</span><br><span class="line">        inc si</span><br><span class="line">        add di, 2</span><br><span class="line">        loop s</span><br><span class="line"></span><br><span class="line">        mov ax, 4c00h</span><br><span class="line">        int 21h</span><br><span class="line">    do0end:</span><br><span class="line">        nop</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></tbody></table></figure>

<h3 id="4-单步中断"><a href="#4-单步中断" class="headerlink" title="4 单步中断"></a>4 单步中断</h3><ul>
<li><p>CPU在执行完一条指令后，如果检测到标志寄存器的TF位为1，则产生单步中断，引发中断过程</p>
</li>
<li><p>中断类型码：1</p>
</li>
<li><p>引发的中断过程：</p>
  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">（1）取得中断类型码1</span><br><span class="line">（2）标志寄存器入栈，TF、IF设置为0 ;防止在中断程序再陷入中断</span><br><span class="line">（3）CS、IP入栈</span><br><span class="line">（4）(IP) = (1 * 4) (CS) = (1 * 4 + 2)</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>CPU提供单步中断功能的原因：为单步跟踪程序的执行过程提供了实现机制</p>
</li>
</ul>
<h2 id="十三-int指令"><a href="#十三-int指令" class="headerlink" title="十三-int指令"></a>十三-int指令</h2><h3 id="1-int指令"><a href="#1-int指令" class="headerlink" title="1 int指令"></a>1 int指令</h3><ul>
<li><p>指令格式：</p>
  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int n</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>n为中断类型码，功能是引发中断过程</p>
</li>
<li><p>指令的执行过程如下：</p>
  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 取中断类型码n</span><br><span class="line">2. 标志寄存器入栈，IF = 0, TF = 0</span><br><span class="line">3. CS、IP入栈</span><br><span class="line">4. (IP) = (n * 4) (CS) = (n * 4 + 2)</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>使用int指令可以调用任何一个中断的中断处理程序</p>
</li>
<li><p>一般情况下，系统将一些具有一定功能的子程序，以中断处理程序的方式提供给应用程序调用，我么可以通过int指令调用这些子程序</p>
</li>
<li><p>我们将中断处理程序简称为“中断例程”</p>
</li>
<li><p>就像call指令和ret指令配合使用那样，我们也常常将int指令和iret指令配合使用，是的在完成中断处理程序之后，接着原来的指令继续执行</p>
</li>
</ul>
<h3 id="2-编写共引用程序调用的中断例程"><a href="#2-编写共引用程序调用的中断例程" class="headerlink" title="2 编写共引用程序调用的中断例程"></a>2 编写共引用程序调用的中断例程</h3><ul>
<li><p>eg1:</p>
  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">;中断7ch的中断例程</span><br><span class="line">;功能：求一word型数据的平方</span><br><span class="line">;参数：(ax) = 要计算的数据</span><br><span class="line">;返回值：dx、ax分别存放结果的高16为和低16位</span><br><span class="line">;应用举例：求2 * 3456</span><br><span class="line">;程序入口：0:200</span><br><span class="line">;表项：7ch</span><br><span class="line">assume cs : code</span><br><span class="line">code segment</span><br><span class="line">start:  </span><br><span class="line">        ;安装中断例程</span><br><span class="line">        ;ds:si指向源地址</span><br><span class="line">        mov ax, cs</span><br><span class="line">        mov ds, ax</span><br><span class="line">        mov si, offset sqr</span><br><span class="line">        ;ed:di指向目的地址</span><br><span class="line">        mov ax, 0</span><br><span class="line">        mov es, ax</span><br><span class="line">        mov di, 200h</span><br><span class="line">        ;设置传输程序长度</span><br><span class="line">        mov cx, offset sqrend - offset sqr</span><br><span class="line">        ;正向传输</span><br><span class="line">        cld</span><br><span class="line">        rep movsb</span><br><span class="line"></span><br><span class="line">        ;设置中断向量表</span><br><span class="line">        mov ax, 0</span><br><span class="line">        mov es, ax</span><br><span class="line">        mov word ptr es:[7ch * 4], 200h</span><br><span class="line">        mov word ptr es:[7ch * 4 + 2], 0 </span><br><span class="line">        </span><br><span class="line">        mov ax, 4c00h</span><br><span class="line">        int 21h</span><br><span class="line"></span><br><span class="line">    sqr:    </span><br><span class="line">        mul ax</span><br><span class="line">        iret</span><br><span class="line">    sqrend:</span><br><span class="line">        nop</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>eg2:</p>
  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">;中断7ch的中断例程</span><br><span class="line">;功能：将一个全是字母，以0结尾的字符串，转化为大写</span><br><span class="line">;参数：ds:si指向字符串的首地址</span><br><span class="line">;应用举例：将data段中的字符串转化为大写</span><br><span class="line">;程序入口地址：0:200</span><br><span class="line">;中断表项：7ch</span><br><span class="line">assume cs : code</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">    db 'conversation', 0</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:  </span><br><span class="line">        ;安装中断程序</span><br><span class="line">        ;ds:si指向源地址</span><br><span class="line">        mov ax, cs</span><br><span class="line">        mov ds, ax</span><br><span class="line">        mov si, offset capital</span><br><span class="line">        ;es:di指向目的地址</span><br><span class="line">        mov ax, 0</span><br><span class="line">        mov es, ax</span><br><span class="line">        mov di, 200h</span><br><span class="line">        ;设置程序长度</span><br><span class="line">        mov cx, offset capital - offset capitalend</span><br><span class="line">        ;正向传输</span><br><span class="line">        cld </span><br><span class="line">        rep movsb</span><br><span class="line">        </span><br><span class="line">        ;设置中断向量表</span><br><span class="line">        mov ax, 0</span><br><span class="line">        mov es, ax </span><br><span class="line">        mov word ptr es:[7ch * 4], 200h</span><br><span class="line">        mov word ptr es:[7ch * 4 + 2], 0</span><br><span class="line"></span><br><span class="line">        mov ax, 4c00h</span><br><span class="line">        int 21h</span><br><span class="line"></span><br><span class="line">capital:    </span><br><span class="line">        push cx</span><br><span class="line">        push si </span><br><span class="line">change:</span><br><span class="line">        mov cl, [si]</span><br><span class="line">        mov ch, 0</span><br><span class="line">        jcxz ok</span><br><span class="line">        and byte ptr [si], 11011111b</span><br><span class="line">        inc si</span><br><span class="line">        jmp short change</span><br><span class="line"></span><br><span class="line">    ok:</span><br><span class="line">        pop si</span><br><span class="line">        pop cx</span><br><span class="line">        iret</span><br><span class="line">capitalend:</span><br><span class="line">        nop</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h3 id="3-对int、ret和栈的深入理解"><a href="#3-对int、ret和栈的深入理解" class="headerlink" title="3 对int、ret和栈的深入理解"></a>3 对int、ret和栈的深入理解</h3><ul>
<li><p>关于bp的说明：</p>
<ul>
<li><p>bp可以和ss联合使用用来访问栈</p>
</li>
<li><p>指令格式:</p>
  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[bp] ;这里默认段地址为ss</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
</li>
<li><p>用7ch中断例程完成loop指令的功能</p>
<ul>
<li><p>程序的安装</p>
  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">;用7ch中断例程完成loop指令的功能</span><br><span class="line">;cx存放循环次数，bx存放位移</span><br><span class="line">;程序入口地址：0:200h</span><br><span class="line">;中断表项：7ch</span><br><span class="line"></span><br><span class="line">assume cs : code</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:  </span><br><span class="line">        ;ds:si指向源地址</span><br><span class="line">        mov ax, cs </span><br><span class="line">        mov ds, ax</span><br><span class="line">        mov si, offset lp</span><br><span class="line">        ;es:di指向目的地址</span><br><span class="line">        mov ax, 0</span><br><span class="line">        mov es, ax</span><br><span class="line">        mov di, 200h</span><br><span class="line">        ;设置传输长度</span><br><span class="line">        mov cx, offset lpend - offset lp</span><br><span class="line">        ;正向传输</span><br><span class="line">        cld</span><br><span class="line">        rep movsb</span><br><span class="line"></span><br><span class="line">        ;设置中断向量表</span><br><span class="line">        mov ax, 0</span><br><span class="line">        mov es, ax</span><br><span class="line">        mov word ptr es:[7ch * 4], 200h</span><br><span class="line">        mov word ptr es:[7ch * 4 + 2], 0</span><br><span class="line"></span><br><span class="line">        mov ax, 4c00h</span><br><span class="line">        int 21h</span><br><span class="line"></span><br><span class="line">lp:     push bp</span><br><span class="line">        mov bp, sp</span><br><span class="line">        dec cx </span><br><span class="line">        jcxz lpret</span><br><span class="line">        add [bp + 2], bx</span><br><span class="line"></span><br><span class="line">lpret:</span><br><span class="line">        pop bp</span><br><span class="line">        iret</span><br><span class="line">lpend:</span><br><span class="line">    nop</span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>程序的调用</p>
  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">;调用7ch中断例程实现的loop功能</span><br><span class="line">;在屏幕中显示80个'!'</span><br><span class="line"></span><br><span class="line">assume cs : code</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:    </span><br><span class="line">        ;设置显示区地址</span><br><span class="line">        mov ax, 0b800h</span><br><span class="line">        mov es, ax</span><br><span class="line">        mov di, 160 * 12 ;从第12行开始</span><br><span class="line">        ;设置从se到s的转移地址</span><br><span class="line">        mov bx, offset s - offset se</span><br><span class="line">        mov cx, 80</span><br><span class="line">    s:  mov byte ptr es:[di], '!'</span><br><span class="line">        add di, 2</span><br><span class="line">        int 7ch</span><br><span class="line">    se: nop</span><br><span class="line">        </span><br><span class="line">        mov ax, 4c00h</span><br><span class="line">        int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
</li>
</ul>
<h3 id="4-BIOS和DOS中断例程"><a href="#4-BIOS和DOS中断例程" class="headerlink" title="4 BIOS和DOS中断例程"></a>4 BIOS和DOS中断例程</h3><ul>
<li>BIOS：系统板的ROM中存放的一套基本输入输出系统程序，</li>
<li>DOS：著名操作系统</li>
<li>BIOS和DOS在所提供的中断例程中包含了许多子程序，这些子程序实现了程序员在编程的时候经常要用到的功能。程序员在编程的时候，可以用int指令直接调用BIOS和DS提供的中断例程来完成某些工作。</li>
<li>和硬件设备相关的DOS中断例程中，一般都调用了BIOS的中断例程</li>
</ul>
<h4 id="4-1-BIOS和DOS中断例程的安装"><a href="#4-1-BIOS和DOS中断例程的安装" class="headerlink" title="4.1 BIOS和DOS中断例程的安装"></a>4.1 BIOS和DOS中断例程的安装</h4><p>安装过程如下：</p>
<ol>
<li>开机后，CPU一加电，初始化(CS) = 0FFFFH，(IP) = 0，自动从FFFF:0单元开始执行程序。FFFF:0有一条跳转指令，CPU执行后转去执行BIOS中的硬件系统检测和初始化程序</li>
<li>初始化程序将建立BIOS所支持的中断向量</li>
<li>完成硬件系统检测和初始化后，调用int19h进行操作系统的引导。计算机交给操作系统控制</li>
<li>DOS启动后，出完成其他工作外，还将它所提供的中断例程装入内存，并建立相应中断向量</li>
</ol>
<h4 id="4-2-BIOS中断例程的应用"><a href="#4-2-BIOS中断例程的应用" class="headerlink" title="4.2 BIOS中断例程的应用"></a>4.2 BIOS中断例程的应用</h4><ul>
<li><p>一个中断例程包含多个子程序，要是要哪个子程序需要通过传递参数来决定</p>
</li>
<li><p>BIOS和DOS提供的子程序，都用ah来传递参数用来表示内部子程序的编号</p>
</li>
<li><p>10h中断例程的两个功能</p>
<ul>
<li><p>设置光标功能</p>
  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">;设置光标位置</span><br><span class="line">;将光标设置到第0页，第5行，第12列</span><br><span class="line">mov ah, 2 ;调用10h号中断例程的2号程序，功能为设置光标位置</span><br><span class="line">mov bh, 0 ;页号</span><br><span class="line">mov dh, 5 ;行号</span><br><span class="line">mov dl, 12;列号</span><br><span class="line">int 10h</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>显示字符功能</p>
  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">;显示字符</span><br><span class="line">;在5行12列显示3个红底高亮闪烁绿色的'a'</span><br><span class="line">mov ah, 9 ;调用10h号中断例程的9号子程序，功能为显示字符</span><br><span class="line">mov al, 'a' ;字符</span><br><span class="line">mov bl, 11001010b ;字符属性</span><br><span class="line">mov bh, 0 ;页号</span><br><span class="line">mov cx, 3 ;重复个数</span><br><span class="line">int 10h</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
</li>
<li><p>10h中断例程的应用：</p>
  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">;在屏幕的第5行12列显示3个红底高亮闪烁绿色的'a'</span><br><span class="line">;字符属性码：11001010b</span><br><span class="line"></span><br><span class="line">assume cs : code</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:  </span><br><span class="line">        ;设置光标位置</span><br><span class="line">        ;将光标设置到第0页，第5行，第12列</span><br><span class="line">        mov ah, 2 ;调用10h号中断例程的2号程序，功能为设置光标位置</span><br><span class="line">        mov bh, 0 ;页号</span><br><span class="line">        mov dh, 5 ;行号</span><br><span class="line">        mov dl, 12;列号</span><br><span class="line">        int 10h</span><br><span class="line"></span><br><span class="line">        ;显示字符</span><br><span class="line">        ;在5行12列显示3个红底高亮闪烁绿色的'a'</span><br><span class="line">        mov ah, 9 ;调用10h号中断例程的9号子程序，功能为显示字符</span><br><span class="line">        mov al, 'a' ;字符</span><br><span class="line">        mov bl, 11001010b ;字符属性</span><br><span class="line">        mov bh, 0 ;页号</span><br><span class="line">        mov cx, 3 ;重复个数</span><br><span class="line">        int 10h</span><br><span class="line"></span><br><span class="line">        mov ax, 4c00h</span><br><span class="line">        int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h4 id="4-3-DOS中断例程的应用"><a href="#4-3-DOS中断例程的应用" class="headerlink" title="4.3 DOS中断例程的应用"></a>4.3 DOS中断例程的应用</h4><ul>
<li><p>21h号中断例程事DOS提供的中断例程，其包含了许多供程序员调用的子程序</p>
</li>
<li><p>21h号中断例程的几个功能：</p>
<ul>
<li><p>程序返回功能</p>
  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">;程序返回</span><br><span class="line">mov ah, 4ch ;调用21h号中断例程的4ch号子程序，功能为程序返回 </span><br><span class="line">mov al, 0 ;返回值</span><br><span class="line">int 21h</span><br><span class="line">&lt;=&gt;</span><br><span class="line">mov ax, 4c00h</span><br><span class="line">int 21h</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>显示字符串功能</p>
  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">;在光标位置显示字符串</span><br><span class="line">ds:dx 指向字符串 ;要显示的字符串需用'$'作为结束符</span><br><span class="line">mov ah, 9</span><br><span class="line">int 21h</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
</li>
<li><p>21h号中断程序的应用：</p>
  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">;在屏幕的5行12列显示字符串'Welcome to masm'</span><br><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">    db 'Welcome to masm', '$'</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:  </span><br><span class="line">        ;设置光标位置</span><br><span class="line">        mov ah, 2</span><br><span class="line">        mov bh, 0</span><br><span class="line">        mov dh, 5</span><br><span class="line">        mov dl, 12</span><br><span class="line">        int 10h</span><br><span class="line"></span><br><span class="line">        ;在光标位置显示字符串</span><br><span class="line">        mov ax, data</span><br><span class="line">        mov ds, ax</span><br><span class="line">        mov dx, 0</span><br><span class="line">        mov ah, 9</span><br><span class="line">        int 21h</span><br><span class="line"></span><br><span class="line">        mov ax, 4c00h</span><br><span class="line">        int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h2 id="十四-端口"><a href="#十四-端口" class="headerlink" title="十四-端口"></a>十四-端口</h2><ul>
<li><p>在PC机系统中，除了各种存储器外，和CPU通过总线相连的芯片，还有以下3种：</p>
<ul>
<li>（1）各种接口卡（eg:网卡、显卡）上的接口芯片，它们控制接口卡进行工作</li>
<li>（2）主板上的接口芯片，CPU通过它们对部分外设进行访问</li>
<li>（3）其他芯片，用来存储相关的系统信息，或进行相关的输入输出处理</li>
</ul>
</li>
<li><p>在这些芯片中，都有一组可以由CPU读写的寄存器，这些物理上不同的芯片，在以下两点相同：</p>
<ul>
<li>（1）都和CPU的总线相连</li>
<li>（2）CPU对它们进行读写的时候都通过控制线向它们所在的芯片发出端口读写命令</li>
</ul>
</li>
<li><p>从CPU的角度，将这些寄存器都当作端口，对它们进行同一编址，从而建立一个统一的端口空间地址</p>
</li>
<li><p>CPU可以直接读写以下3个地方的数据：</p>
<ul>
<li>（1）CPU内部的寄存器</li>
<li>（2）内存单元</li>
<li>（3）端口</li>
</ul>
</li>
</ul>
<h3 id="1-端口的读写"><a href="#1-端口的读写" class="headerlink" title="1 端口的读写"></a>1 端口的读写</h3><ul>
<li><p>在访问端口的时候，CPU通过端口地址来定位端口</p>
</li>
<li><p>端口地址和内存地址一样，通过地址总线来传送</p>
</li>
<li><p>在PC系统中做多可以定位64KB个不同的端口，端口地址的范围为0~65535</p>
</li>
<li><p>对端口的读写不能使用mov、push、pop等内存读写指令</p>
</li>
<li><p>端口的读写指令只有两条：</p>
  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">in  ;从端口读取数据</span><br><span class="line">out ;往端口写入数据</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>CPU访问内存和访问端口时，总线上的信息：</p>
<ul>
<li><p>访问内存：</p>
  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov ax, ds:[8] ;假定(ds) = 0</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>（1）CPU通过地址线将地址信息8发出</li>
<li>（2）CPU通过控制线发出内存读命令，选中存储器芯片，并通知它，将要从中读取数据</li>
<li>（3）存储器将8号单元中的数据通过数据线送入CPU</li>
</ul>
</li>
<li><p>访问端口：</p>
  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">in al, 60h</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>（1）CPU通过地址先将地址信息60h发出</li>
<li>（2）CPU通过控制线发出端口读命令，选中端口所在的芯片，并通知它，将要从中读取数据</li>
<li>（3）端口所在的芯片将60h端口的数据通过数据线送入CPU</li>
</ul>
</li>
</ul>
</li>
<li><p>在in和out指令中，只能使用ax和al来存放从端口中读入的数据或要发送到端口的数据。访问8为端口时用al，访问16为端口时用ax</p>
<ul>
<li><p>对0~255范围的端口进行读写：</p>
  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">in al, 20h	;从20h端口读入一个字节</span><br><span class="line">out 20h, al	;往20h端口写入一个字节</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>对256~65535范围的端口进行读写：</p>
  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov dx, 3f8h	;将端口号3f8h送入dx</span><br><span class="line">in al, dx		;从3f8h端口读入一个字节</span><br><span class="line">out dx, al		;向3f8h端口写入一个字节</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
</li>
<li><p>CMOS RAM芯片的读写：</p>
<ul>
<li><p>读写步骤：</p>
<ul>
<li>（1）将读写的单元号送入端口70h（地址端口），选定要读写的单元</li>
<li>（2）与端口71h（数据端口）进行数据交互</li>
</ul>
</li>
<li><p>eg：读CMOS RAM的2号单元</p>
  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov al, 2</span><br><span class="line">out 70h, al</span><br><span class="line">in ax, 71h</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
</li>
</ul>
<h3 id="2-shl-和-shr指令"><a href="#2-shl-和-shr指令" class="headerlink" title="2 shl 和 shr指令"></a>2 shl 和 shr指令</h3><ul>
<li><p>shl</p>
<ul>
<li><p>功能：</p>
<ul>
<li>（1）将一个寄存器或内存单元中的数据向左移位</li>
<li>（2）将最后移出的一位写入CF中</li>
<li>（3）最低为用0补充</li>
</ul>
</li>
<li><p>将$X$逻辑左移一位，相当于执行 $X = X * 2$</p>
</li>
<li><p>指令：</p>
  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov al, 01001000b</span><br><span class="line">shr al, 1 ;将al中的数据左移一位</span><br></pre></td></tr></tbody></table></figure>

<p>  执行后，(al) = 1001000b，CF = 0</p>
</li>
<li><p>移动位数大于1，必须将移动位数放在cl中</p>
  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov al, 01010001b</span><br><span class="line">mov cl, 3</span><br><span class="line">shl al, cl</span><br></pre></td></tr></tbody></table></figure>

<p>  执行后，(al) = 10001000b，CF = 0</p>
</li>
</ul>
</li>
<li><p>shr</p>
<ul>
<li><p>功能：</p>
<ul>
<li>（1）将一个寄存器或内存单元中的数据向右移位</li>
<li>（2）将最后移出的一位写入CF中</li>
<li>（3）最高位用0补充</li>
</ul>
</li>
<li><p>将$X$逻辑右移一位，相当于执行$X = X / 2$</p>
</li>
<li><p>指令：</p>
  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov al, 01010001b</span><br><span class="line">mov cl, 3</span><br><span class="line">shr al, cl</span><br></pre></td></tr></tbody></table></figure>

<p>  执行后，(al) = 00001010b，CF = 0</p>
</li>
</ul>
</li>
</ul>
<h3 id="3-显示CMOS-RSM中存储的时间信息"><a href="#3-显示CMOS-RSM中存储的时间信息" class="headerlink" title="3 显示CMOS RSM中存储的时间信息"></a>3 显示CMOS RSM中存储的时间信息</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">;编程，在屏幕中间显示当前的月份</span><br><span class="line">;（1）从CMOS RAM的8号单元中读出当前月份的BCD码</span><br><span class="line">;（2）将用BCD码表示的月份以十进制的形式显示到屏幕上</span><br><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:  </span><br><span class="line">        ;读取BCD码</span><br><span class="line">        mov al, 8</span><br><span class="line">        out 70h, al</span><br><span class="line">        in al, 71h</span><br><span class="line"></span><br><span class="line">        ;BCD码的十位放在ah，个位放在zl</span><br><span class="line">        mov ah, al</span><br><span class="line">        mov cl, 4</span><br><span class="line">        shr ah, cl</span><br><span class="line">        and al, 00001111b</span><br><span class="line">        ;转化为ASCII码值</span><br><span class="line">        add ah, 30h</span><br><span class="line">        add al, 30h</span><br><span class="line">        ;显示字符</span><br><span class="line">        mov bx, 0b800h</span><br><span class="line">        mov es, bx</span><br><span class="line">        mov byte ptr es:[160 * 12 + 40 * 2], ah</span><br><span class="line">        mov byte ptr es:[160 * 12 + 40 * 2 + 2], al</span><br><span class="line"></span><br><span class="line">        mov ax, 4c00h</span><br><span class="line">        int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></tbody></table></figure>



<h2 id="十五-外中断"><a href="#十五-外中断" class="headerlink" title="十五-外中断"></a>十五-外中断</h2><ul>
<li>CPU在计算机系统中，除了能够执行指令，进行运算，还应该能够对外部设备进行控制，与其进行输入输出的交互</li>
<li>要及时处理外设的输入，需解决两个问题：<ul>
<li>（1）外设的输入随时可能发生，CPU如何得知？</li>
<li>（2）CPU从何处得到外设的输入？</li>
</ul>
</li>
</ul>
<h3 id="1-接口芯片与端口"><a href="#1-接口芯片与端口" class="headerlink" title="1 接口芯片与端口"></a>1 接口芯片与端口</h3><p>CPU从何处得到外设的输入？</p>
<ul>
<li>PC系统的接口卡和主板上，装有各种接口芯片。这些外设接口芯片的内部有若干寄存器，CPU将这些寄存器当作端口来访问</li>
<li>CPU通过端口和外部设备进行联系</li>
</ul>
<h3 id="2-外中断信息"><a href="#2-外中断信息" class="headerlink" title="2 外中断信息"></a>2 外中断信息</h3><p>外设随时都可能发生需要CPU即时处理的事件，CPU如何得知并进行处理？</p>
<ul>
<li><p>CPU提供中断机制来满足这种要求</p>
</li>
<li><p>外中断：中断信息来自外部</p>
</li>
<li><p>外中断源：</p>
<ul>
<li><p>可屏蔽中断源：</p>
<ul>
<li><p>CPU可以不响应的外中断</p>
</li>
<li><p>CPU检测到可屏蔽中断信息时，如果IF = 1，则CPU在执行完当前指令后相应中断；如果IF = 0，则CPU响应可屏蔽中断</p>
</li>
<li><p>设置IF的指令：</p>
  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sti ;设置IF = 1</span><br><span class="line">cli ;设置IF = 0</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
</li>
<li><p>不可屏蔽中断：</p>
<ul>
<li>CPU必须响应的外中断</li>
<li>当CPU检测到不可屏蔽中断信息时，则在执行完当前指令后，立即响应，引发中断过程</li>
</ul>
</li>
</ul>
</li>
<li><p>几乎所有外设引发的外中断，都是可屏蔽中断，不可屏蔽中断是在系统系统中有必须处理的紧急情况发生时用来通知CPU的中断信息，我们主要讨论可屏蔽中断</p>
</li>
</ul>
<h3 id="3-PC机键盘的处理过程"><a href="#3-PC机键盘的处理过程" class="headerlink" title="3 PC机键盘的处理过程"></a>3 PC机键盘的处理过程</h3><h4 id="3-1-键盘键入"><a href="#3-1-键盘键入" class="headerlink" title="3.1 键盘键入"></a>3.1 键盘键入</h4><ul>
<li><p>键盘上每一个键相当于一个开关，键盘中有一个芯片对键盘上的每一个键的开关状态进行扫描</p>
</li>
<li><p>按下一个键，开关接通，芯片产生一个扫描码，称为“通码”。通码说明了按下的键在键盘中的位置，通码被送入主板上相关接口芯片的寄存器中，该寄存器的端口地址位60h</p>
</li>
<li><p>松开按下的键，开关断开，芯片产生一个扫描码，称为“断码”，断码被送入60端口中</p>
</li>
<li><p>扫描码的长度为0，通码的第7位为0，断码的第7位为1，$断码 = 通码 + 80h$</p>
</li>
</ul>
<h4 id="3-2-引发9号中断"><a href="#3-2-引发9号中断" class="headerlink" title="3.2 引发9号中断"></a>3.2 引发9号中断</h4><p>键盘的输入到达60h端口时，相关的芯片就会向CPU发出中断类型码为9的可屏蔽中断信息。CPU检测到该中断信息后，如果IF = 1，则响应中断，引发中断过程，转去执行9号中断例程</p>
<h4 id="3-3-执行int-9中断例程"><a href="#3-3-执行int-9中断例程" class="headerlink" title="3.3 执行int 9中断例程"></a>3.3 执行int 9中断例程</h4><ul>
<li>BIOS提供了int 9中断例程，用来进行基本的键盘输入处理，主要工作如下：<ul>
<li>（1）读出60h端口中的扫描码</li>
<li>（2）若是字符键扫描码，将扫描码和对应的字符码送入BIOS键盘缓冲区；若是控制键和切换键的扫描码，则将其转变为状态字节写入内存中存储状态字节的单元</li>
<li>（3）对键盘系统进行相关的控制</li>
</ul>
</li>
<li>BIOS键盘缓冲区：系统启动后，BIOS用于存放int 9中断例程所接收的键盘输入的内存区</li>
<li>在BIOS键盘缓冲区中，一个键盘输入用一个字单元存放，高位字节存放扫描码，低位字节存放扫描码对应的字符码</li>
<li>0040:17单元存储键盘状态字节，该字节记录了控制键和切换键的状态。键盘状态字节的不同位代表不同键位的状态信息</li>
</ul>
<p>图床：<a target="_blank" rel="noopener" href="https://imgur.com/a/f6Yztwj">https://imgur.com/a/f6Yztwj</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://ghost89757.github.io">loudmute</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://ghost89757.github.io/post/1ded95c1.html">https://ghost89757.github.io/post/1ded95c1.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://ghost89757.github.io" target="_blank">loudmute</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%BC%96%E7%A8%8B/">编程</a><a class="post-meta__tags" href="/tags/%E6%B1%87%E7%BC%96/">汇编</a></div><div class="post_share"><div class="social-share" data-image="/img/7.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer=""></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/post/f357c59c.html"><img class="prev-cover" src="/img/8.jpg" onerror="onerror=null;src='/img/p6.png'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">哈工大OSLab0-实验准备</div></div></a></div><div class="next-post pull-right"><a href="/post/63fbc417.html"><img class="next-cover" src="/img/6.jpg" onerror="onerror=null;src='/img/p6.png'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">无监督自适应（UDA）：让网络模型学会举一反三</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/post/f4aaaaf3.html" title="Numpy总结-1.Numpy ndaay"><img class="cover" src="/img/4.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-07</div><div class="title">Numpy总结-1.Numpy ndaay</div></div></a></div><div><a href="/post/2bc0248d.html" title="Numpy总结-2.通用函数"><img class="cover" src="/img/5.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-07</div><div class="title">Numpy总结-2.通用函数</div></div></a></div><div><a href="/post/93a871b9.html" title="Numpy总结-3.面向数组编程"><img class="cover" src="/img/6.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-07</div><div class="title">Numpy总结-3.面向数组编程</div></div></a></div><div><a href="/post/5140763b.html" title="Numpy总结-4.用数组进行文件输入输出"><img class="cover" src="/img/7.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-07</div><div class="title">Numpy总结-4.用数组进行文件输入输出</div></div></a></div><div><a href="/post/c2047baa.html" title="Numpy总结-5.线性代数"><img class="cover" src="/img/8.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-07</div><div class="title">Numpy总结-5.线性代数</div></div></a></div><div><a href="/post/4269cbfe.html" title="Numpy总结-6.伪随机函数的生成"><img class="cover" src="/img/9.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-07</div><div class="title">Numpy总结-6.伪随机函数的生成</div></div></a></div></div></div><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div id="comment-switch"><span class="first-comment">Valine</span><span class="switch-btn"></span><span class="second-comment">Disqus</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div><div><div id="disqus_thread"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/head-1.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"></div><div class="author-info__name">loudmute</div><div class="author-info__description">一直游到，海水变蓝</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">35</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">23</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">16</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/ghost89757"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-text">一-基础知识</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%88%E6%8C%87%E4%BB%A4%E8%AE%BF%E9%97%AE%EF%BC%89"><span class="toc-text">二-寄存器（指令访问）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%87%A0%E6%9D%A1%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4"><span class="toc-text">1 几条汇编指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-CS%E5%92%8CIP"><span class="toc-text">2 CS和IP</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="toc-text">2.1 相关概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-%E7%9B%B8%E5%85%B3%E6%8C%87%E4%BB%A4"><span class="toc-text">2.2 相关指令</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89-%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%88%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE%EF%BC%89"><span class="toc-text">三-寄存器（内存访问）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-DS%E5%92%8C-address"><span class="toc-text">1 DS和[address]</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="toc-text">1.1 相关概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-%E7%9B%B8%E5%85%B3%E6%8C%87%E4%BB%A4"><span class="toc-text">1.2 相关指令</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-mov%E3%80%81add%E3%80%81sub%E6%8C%87%E4%BB%A4"><span class="toc-text">2 mov、add、sub指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%A0%88"><span class="toc-text">3 栈</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="toc-text">3.1 相关概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-%E7%9B%B8%E5%85%B3%E6%8C%87%E4%BB%A4"><span class="toc-text">3.2 相关指令</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B-%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8F"><span class="toc-text">四-第一个程序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8F%E4%BB%8E%E5%86%99%E5%87%BA%E5%88%B0%E6%89%A7%E8%A1%8C%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-text">1 一个程序从写出到执行的过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E6%BA%90%E7%A8%8B%E5%BA%8F"><span class="toc-text">2 一个简单的源程序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94-BX-%E5%92%8Cloop%E6%8C%87%E4%BB%A4"><span class="toc-text">五-[BX]和loop指令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-BX"><span class="toc-text">1 [BX]</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Loop%E6%8C%87%E4%BB%A4"><span class="toc-text">2 Loop指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%AE%B5%E5%89%8D%E7%BC%80"><span class="toc-text">3 段前缀</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5-1"><span class="toc-text">3.1 相关概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-%E6%AE%B5%E5%89%8D%E7%BC%80%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">3.2 段前缀的使用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD-%E5%8C%85%E5%90%AB%E5%A4%9A%E4%B8%AA%E6%AE%B5%E7%9A%84%E7%A8%8B%E5%BA%8F"><span class="toc-text">六-包含多个段的程序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%9C%A8%E4%BB%A3%E7%A0%81%E6%AE%B5%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%95%B0%E6%8D%AE"><span class="toc-text">1 在代码段中使用数据</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E5%AE%9A%E4%B9%89%E6%95%B0%E6%8D%AE"><span class="toc-text">1.1 定义数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-%E6%8C%87%E6%98%8E%E7%A8%8B%E5%BA%8F%E5%85%A5%E5%8F%A3"><span class="toc-text">1.2 指明程序入口</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%9C%A8%E4%BB%A3%E7%A0%81%E6%AE%B5%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%A0%88"><span class="toc-text">2 在代码段中使用栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%B0%86%E6%95%B0%E6%8D%AE%E3%80%81%E4%BB%A3%E7%A0%81%E3%80%81%E6%A0%88%E6%94%BE%E5%85%A5%E4%B8%8D%E5%90%8C%E7%9A%84%E6%AE%B5"><span class="toc-text">3 将数据、代码、栈放入不同的段</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83-%E6%9B%B4%E7%81%B5%E6%B4%BB%E7%9A%84%E5%AE%9A%E4%B9%89%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">七-更灵活的定义内存地址的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-and-%E5%92%8C-or-%E6%8C%87%E4%BB%A4"><span class="toc-text">1 and 和 or 指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BB%A5%E5%AD%97%E7%AC%A6%E5%BD%A2%E5%BC%8F%E7%BB%99%E5%87%BA%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="toc-text">2 以字符形式给出的数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%A4%A7%E5%B0%8F%E5%86%99%E8%BD%AC%E6%8D%A2%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-text">3 大小写转换的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-bx-idata"><span class="toc-text">4 [bx + idata]</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="toc-text">4.1 相关概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-%E7%94%A8-bx-idata-%E5%A4%84%E7%90%86%E6%95%B0%E7%BB%84"><span class="toc-text">4.2 用[bx + idata]处理数组</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-SI%E5%92%8CDI"><span class="toc-text">5 SI和DI</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-bx-si-%E5%92%8C-bx-di"><span class="toc-text">6 [bx + si] 和 [bx + di]</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-bx-si-idata-%E5%92%8C-bx-di-idata"><span class="toc-text">7 [bx + si + idata] 和 [bx + di + idata]</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E5%87%A0%E7%A7%8D%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F"><span class="toc-text">8 几种寻址方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-1-%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F"><span class="toc-text">8.1 寻址方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-%E4%B8%80%E4%B8%AA%E5%B5%8C%E5%A5%97%E5%BE%AA%E7%8E%AF%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="toc-text">8.2 一个嵌套循环的例子</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB-%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%9F%BA%E6%9C%AC%E9%97%AE%E9%A2%98"><span class="toc-text">八-数据处理的两个基本问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-bx%E3%80%81si%E3%80%81di-%E5%92%8C-bp"><span class="toc-text">1 bx、si、di 和 bp</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%9C%BA%E5%99%A8%E6%8C%87%E4%BB%A4%E5%A4%84%E7%90%86%E7%9A%84%E6%95%B0%E6%8D%AE%E5%9C%A8%E4%BB%80%E4%B9%88%E5%9C%B0%E6%96%B9"><span class="toc-text">2 机器指令处理的数据在什么地方</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E4%B8%AD%E6%95%B0%E6%8D%AE%E4%BD%8D%E7%BD%AE%E7%9A%84%E8%A1%A8%E8%BE%BE"><span class="toc-text">3 汇编语言中数据位置的表达</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F"><span class="toc-text">4 寻址方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%8C%87%E4%BB%A4%E8%A6%81%E5%A4%84%E7%90%86%E7%9A%84%E6%95%B0%E6%8D%AE%E6%9C%89%E5%A4%9A%E9%95%BF"><span class="toc-text">5 指令要处理的数据有多长</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%E7%9A%84%E7%BB%BC%E5%90%88%E5%BA%94%E7%94%A8"><span class="toc-text">6 寻址方式的综合应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-div%E6%8C%87%E4%BB%A4"><span class="toc-text">7 div指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E4%BC%AA%E6%8C%87%E4%BB%A4dd"><span class="toc-text">8 伪指令dd</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-dup"><span class="toc-text">9 dup</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%9D-%E8%BD%AC%E7%A7%BB%E6%8C%87%E4%BB%A4%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-text">九-转移指令的原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%93%8D%E4%BD%9C%E7%AC%A6-offset"><span class="toc-text">1 操作符 offset</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-jmp%E6%8C%87%E4%BB%A4"><span class="toc-text">2 jmp指令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E6%A0%B9%E6%8D%AE%E4%BD%8D%E7%A7%BB%E8%BF%9B%E8%A1%8C%E8%BD%AC%E7%A7%BB%E7%9A%84jmp%E6%8C%87%E4%BB%A4"><span class="toc-text">2.1 根据位移进行转移的jmp指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-%E8%BD%AC%E7%A7%BB%E7%9B%AE%E7%9A%84%E5%9C%B0%E5%9D%80%E5%9C%A8%E6%8C%87%E4%BB%A4%E4%B8%AD%E7%9A%84jmp%E6%8C%87%E4%BB%A4"><span class="toc-text">2.2 转移目的地址在指令中的jmp指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-%E8%BD%AC%E7%A7%BB%E5%9C%B0%E5%9D%80%E5%9C%A8%E5%AF%84%E5%AD%98%E5%99%A8%E4%B8%AD%E7%9A%84jmp%E6%8C%87%E4%BB%A4"><span class="toc-text">2.3 转移地址在寄存器中的jmp指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-%E8%BD%AC%E7%A7%BB%E5%9C%B0%E5%9D%80%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84jmp%E6%8C%87%E4%BB%A4"><span class="toc-text">2.4 转移地址在内存中的jmp指令</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-jcxz-%E6%8C%87%E4%BB%A4"><span class="toc-text">3 jcxz 指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-loop-%E6%8C%87%E4%BB%A4"><span class="toc-text">4 loop 指令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81-CALL-%E5%92%8C-RET-%E6%8C%87%E4%BB%A4"><span class="toc-text">十-CALL 和 RET 指令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-ret-%E5%92%8C-retf"><span class="toc-text">1 ret 和 retf</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-call%E6%8C%87%E4%BB%A4"><span class="toc-text">2 call指令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E4%BE%9D%E6%8D%AE%E4%BD%8D%E7%A7%BB%E8%BF%9B%E8%A1%8C%E8%BD%AC%E7%A7%BB%E7%9A%84call%E6%8C%87%E4%BB%A4"><span class="toc-text">2.1 依据位移进行转移的call指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-%E8%BD%AC%E7%A7%BB%E7%9B%AE%E7%9A%84%E5%9C%B0%E5%9D%80%E5%9C%A8%E6%8C%87%E4%BB%A4%E4%B8%AD%E7%9A%84call%E6%8C%87%E4%BB%A4"><span class="toc-text">2.2 转移目的地址在指令中的call指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-%E8%BD%AC%E7%A7%BB%E5%9C%B0%E5%9D%80%E5%9C%A8%E5%AF%84%E5%AD%98%E5%99%A8%E4%B8%AD%E7%9A%84call%E6%8C%87%E4%BB%A4"><span class="toc-text">2.3 转移地址在寄存器中的call指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-%E8%BD%AC%E7%A7%BB%E5%9C%B0%E5%9D%80%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84call%E6%8C%87%E4%BB%A4"><span class="toc-text">2.4 转移地址在内存中的call指令</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-call-%E5%92%8C-ret-%E7%9A%84%E9%85%8D%E5%90%88%E4%BD%BF%E7%94%A8"><span class="toc-text">3 call 和 ret 的配合使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-mul-%E6%8C%87%E4%BB%A4"><span class="toc-text">4 mul 指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%A8%A1%E5%9D%97%E5%8C%96%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%8F%8A%E5%85%B6%E9%97%AE%E9%A2%98"><span class="toc-text">5 模块化程序设计及其问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-%E5%8F%82%E6%95%B0%E5%92%8C%E7%BB%93%E6%9E%9C%E4%BC%A0%E9%80%92%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-text">5.1 参数和结果传递的问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-%E6%89%B9%E9%87%8F%E6%95%B0%E6%8D%AE%E7%9A%84%E4%BC%A0%E9%80%92"><span class="toc-text">5.2 批量数据的传递</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-%E5%AF%84%E5%AD%98%E5%99%A8%E5%86%B2%E7%AA%81%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-text">5.3 寄存器冲突的问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%B8%80-%E6%A0%87%E5%BF%97%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-text">十一-标志寄存器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-ZF%E6%A0%87%E5%BF%97"><span class="toc-text">1 ZF标志</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-PF%E6%A0%87%E5%BF%97"><span class="toc-text">2 PF标志</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-SF%E6%A0%87%E5%BF%97"><span class="toc-text">3 SF标志</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-CF%E6%A0%87%E5%BF%97"><span class="toc-text">4 CF标志</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-OF%E6%A0%87%E5%BF%97"><span class="toc-text">5 OF标志</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-adc%E6%8C%87%E4%BB%A4"><span class="toc-text">6 adc指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-sbb%E6%8C%87%E4%BB%A4"><span class="toc-text">7 sbb指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-cmp%E6%8C%87%E4%BB%A4"><span class="toc-text">8 cmp指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E6%A3%80%E6%B5%8B%E6%AF%94%E8%BE%83%E7%BB%93%E6%9E%9C%E7%9A%84%E6%9D%A1%E4%BB%B6%E8%BD%AC%E7%A7%BB%E6%8C%87%E4%BB%A4"><span class="toc-text">9 检测比较结果的条件转移指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-DF%E6%A0%87%E5%BF%97%E5%92%8C%E4%B8%B2%E4%BC%A0%E9%80%81%E6%8C%87%E4%BB%A4"><span class="toc-text">10 DF标志和串传送指令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#10-1-DF%E6%A0%87%E5%BF%97"><span class="toc-text">10.1 DF标志</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-2-%E4%B8%B2%E4%BC%A0%E9%80%81%E6%8C%87%E4%BB%A4"><span class="toc-text">10.2 串传送指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-3-%E4%B8%B2%E4%BC%A0%E9%80%81%E6%8C%87%E4%BB%A4%E4%B8%8Erep%E6%8C%87%E4%BB%A4%E7%9A%84%E9%85%8D%E5%90%88"><span class="toc-text">10.3 串传送指令与rep指令的配合</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-4-%E5%AF%B9df%E8%BF%9B%E8%A1%8C%E8%AE%BE%E7%BD%AE%EF%BC%9A"><span class="toc-text">10.4 对df进行设置：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-5-%E5%BA%94%E7%94%A8%E4%B8%BE%E4%BE%8B"><span class="toc-text">10.5 应用举例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-pushf-%E5%92%8C-popf"><span class="toc-text">11 pushf 和 popf</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%BA%8C-%E5%86%85%E4%B8%AD%E6%96%AD"><span class="toc-text">十二-内中断</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%B8%AD%E6%96%AD%E8%BF%87%E7%A8%8B"><span class="toc-text">1 中断过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F%E5%92%8Ciret%E6%8C%87%E4%BB%A4"><span class="toc-text">2 中断处理程序和iret指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-0%E5%8F%B7%E4%B8%AD%E6%96%AD%E7%A8%8B%E5%BA%8F%E7%BC%96%E5%86%99"><span class="toc-text">3 0号中断程序编写</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%8D%95%E6%AD%A5%E4%B8%AD%E6%96%AD"><span class="toc-text">4 单步中断</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%B8%89-int%E6%8C%87%E4%BB%A4"><span class="toc-text">十三-int指令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-int%E6%8C%87%E4%BB%A4"><span class="toc-text">1 int指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%BC%96%E5%86%99%E5%85%B1%E5%BC%95%E7%94%A8%E7%A8%8B%E5%BA%8F%E8%B0%83%E7%94%A8%E7%9A%84%E4%B8%AD%E6%96%AD%E4%BE%8B%E7%A8%8B"><span class="toc-text">2 编写共引用程序调用的中断例程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%AF%B9int%E3%80%81ret%E5%92%8C%E6%A0%88%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3"><span class="toc-text">3 对int、ret和栈的深入理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-BIOS%E5%92%8CDOS%E4%B8%AD%E6%96%AD%E4%BE%8B%E7%A8%8B"><span class="toc-text">4 BIOS和DOS中断例程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-BIOS%E5%92%8CDOS%E4%B8%AD%E6%96%AD%E4%BE%8B%E7%A8%8B%E7%9A%84%E5%AE%89%E8%A3%85"><span class="toc-text">4.1 BIOS和DOS中断例程的安装</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-BIOS%E4%B8%AD%E6%96%AD%E4%BE%8B%E7%A8%8B%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-text">4.2 BIOS中断例程的应用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-DOS%E4%B8%AD%E6%96%AD%E4%BE%8B%E7%A8%8B%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-text">4.3 DOS中断例程的应用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E5%9B%9B-%E7%AB%AF%E5%8F%A3"><span class="toc-text">十四-端口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%AB%AF%E5%8F%A3%E7%9A%84%E8%AF%BB%E5%86%99"><span class="toc-text">1 端口的读写</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-shl-%E5%92%8C-shr%E6%8C%87%E4%BB%A4"><span class="toc-text">2 shl 和 shr指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%98%BE%E7%A4%BACMOS-RSM%E4%B8%AD%E5%AD%98%E5%82%A8%E7%9A%84%E6%97%B6%E9%97%B4%E4%BF%A1%E6%81%AF"><span class="toc-text">3 显示CMOS RSM中存储的时间信息</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%BA%94-%E5%A4%96%E4%B8%AD%E6%96%AD"><span class="toc-text">十五-外中断</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%8E%A5%E5%8F%A3%E8%8A%AF%E7%89%87%E4%B8%8E%E7%AB%AF%E5%8F%A3"><span class="toc-text">1 接口芯片与端口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%A4%96%E4%B8%AD%E6%96%AD%E4%BF%A1%E6%81%AF"><span class="toc-text">2 外中断信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-PC%E6%9C%BA%E9%94%AE%E7%9B%98%E7%9A%84%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B"><span class="toc-text">3 PC机键盘的处理过程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-%E9%94%AE%E7%9B%98%E9%94%AE%E5%85%A5"><span class="toc-text">3.1 键盘键入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-%E5%BC%95%E5%8F%919%E5%8F%B7%E4%B8%AD%E6%96%AD"><span class="toc-text">3.2 引发9号中断</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-%E6%89%A7%E8%A1%8Cint-9%E4%B8%AD%E6%96%AD%E4%BE%8B%E7%A8%8B"><span class="toc-text">3.3 执行int 9中断例程</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/77bff30b.html" title="UnityNote3-物理系统">UnityNote3-物理系统</a><time datetime="2025-02-08T10:08:29.000Z" title="发表于 2025-02-08 18:08:29">2025-02-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/27a89f23.html" title="UnityNote2-基本概念和脚本编程">UnityNote2-基本概念和脚本编程</a><time datetime="2025-02-05T13:45:47.000Z" title="发表于 2025-02-05 21:45:47">2025-02-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/9fcb3586.html" title="UnityNote1-初识Unity">UnityNote1-初识Unity</a><time datetime="2025-01-17T08:38:05.000Z" title="发表于 2025-01-17 16:38:05">2025-01-17</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/e2adc0a9.html" title="我的考研">我的考研</a><time datetime="2024-12-27T11:50:30.000Z" title="发表于 2024-12-27 19:50:30">2024-12-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/3bcf039.html" title="真正的英雄主义">真正的英雄主义</a><time datetime="2024-12-01T08:47:06.000Z" title="发表于 2024-12-01 16:47:06">2024-12-01</time></div></div></div></div></div></div></main><footer id="footer" style="background: transparent"><div id="footer-wrap"><div class="copyright">©2022 - 2025 By loudmute</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container').forEach(node => {
            if (node.hasAttribute('display')) {
              btf.wrap(node, 'div', { class: 'mathjax-overflow' })
            } else {
              btf.wrap(node, 'span', { class: 'mathjax-overflow' })
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '',
      appKey: '',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script><script>function loadDisqus () {
  var disqus_config = function () {
    this.page.url = 'https://ghost89757.github.io/post/1ded95c1.html'
    this.page.identifier = '/post/1ded95c1.html'
    this.page.title = '王爽《汇编语言》总结'
  };

  window.disqusReset = () => {
    DISQUS.reset({
      reload: true,
      config: disqus_config
    })
  }

  if (window.DISQUS) disqusReset()
  else {
    (function() { 
      var d = document, s = d.createElement('script');
      s.src = 'https://.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  }

  document.getElementById('darkmode').addEventListener('click', () => {
    setTimeout(() => window.disqusReset(), 200)
  })
}

if ('Valine' === 'Disqus' || !true) {
  if (true) btf.loadComment(document.getElementById('disqus_thread'), loadDisqus)
  else loadDisqus()
} else {
  function loadOtherComment () {
    loadDisqus()
  }
}
</script></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script async="" data-pjax="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"left","width":120,"height":240,"hOffset":0,"vOffset":-45},"mobile":{"show":true},"react":{"opacity":1},"log":false});</script></body></html>